<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>echars学习</title>
    <url>/2022/07/07/echars%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="1安装echars"><a class="markdownIt-Anchor" href="#1安装echars">#</a> 1. 安装 echars</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install echarts --save</span><br></pre></td></tr></table></figure>
<h4 id="2引入使用echars"><a class="markdownIt-Anchor" href="#2引入使用echars">#</a> 2. 引入使用 echars</h4>
<h5 id="1方法一"><a class="markdownIt-Anchor" href="#1方法一">#</a> 1. 方法一</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.准备好一个容器,必须设置宽度和高度</span></span><br><span class="line">&lt;div id= <span class="string">&#x27;main&#x27;</span>&gt;</span><br><span class="line">    </span><br><span class="line"> &lt;/div&gt;   </span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">&#x27;echarts&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.基于准备好的dom，初始化echarts实例</span></span><br><span class="line"><span class="keyword">var</span> dom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;container&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> myChart = echarts.<span class="title function_">init</span>(dom);</span><br><span class="line"><span class="comment">// 3.传入数据</span></span><br><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">    <span class="attr">xAxis</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tue&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thu&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">yAxis</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">series</span>: [&#123;</span><br><span class="line">        <span class="attr">data</span>: [<span class="number">820</span>, <span class="number">932</span>, <span class="number">901</span>, <span class="number">934</span>, <span class="number">1290</span>, <span class="number">1330</span>, <span class="number">1320</span>],<span class="comment">//在这里修改数据</span></span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;line&#x27;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//4.绘制图表</span></span><br><span class="line"><span class="keyword">if</span> (option &amp;&amp; <span class="keyword">typeof</span> option === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    myChart.<span class="title function_">setOption</span>(option, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2方法二"><a class="markdownIt-Anchor" href="#2方法二">#</a> 2. 方法二</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.准备好一个容器,必须设置宽度和高度</span></span><br><span class="line">&lt;div id= <span class="string">&#x27;main&#x27;</span>&gt;</span><br><span class="line">    </span><br><span class="line"> &lt;/div&gt;   </span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">&#x27;echarts&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.基于准备好的dom，初始化echarts实例</span></span><br><span class="line"><span class="keyword">var</span> myChart = echarts.<span class="title function_">init</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;main&#x27;</span>));</span><br><span class="line"><span class="comment">// 绘制图表</span></span><br><span class="line">myChart.<span class="title function_">setOption</span>(&#123;</span><br><span class="line">  <span class="attr">title</span>: &#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;ECharts 入门示例&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">tooltip</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">xAxis</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: [<span class="string">&#x27;衬衫&#x27;</span>, <span class="string">&#x27;羊毛衫&#x27;</span>, <span class="string">&#x27;雪纺衫&#x27;</span>, <span class="string">&#x27;裤子&#x27;</span>, <span class="string">&#x27;高跟鞋&#x27;</span>, <span class="string">&#x27;袜子&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">yAxis</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">series</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;销量&#x27;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: [<span class="number">5</span>, <span class="number">20</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3echars中的配置项"><a class="markdownIt-Anchor" href="#3echars中的配置项">#</a> 3.echars 中的配置项</h4>
<h5 id="1title"><a class="markdownIt-Anchor" href="#1title">#</a> 1.title</h5>
<p>标题组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id：默认不指定</span><br><span class="line">show：true是否显示标题组件</span><br><span class="line">text：&#x27;&#x27;主标题文本（支持换行\n）</span><br><span class="line">link：&#x27;&#x27;主标题文本超链接</span><br></pre></td></tr></table></figure>
<h5 id="2legend"><a class="markdownIt-Anchor" href="#2legend">#</a> 2.legend</h5>
<p>图例标签</p>
<h5 id="3grid"><a class="markdownIt-Anchor" href="#3grid">#</a> 3.grid</h5>
<p>直角坐标系内绘制网络</p>
<h5 id="4xaxis"><a class="markdownIt-Anchor" href="#4xaxis">#</a> 4.xAxis</h5>
<p>直角坐标系 grid 的 x 轴</p>
<h5 id="5yaxis"><a class="markdownIt-Anchor" href="#5yaxis">#</a> 5.yAxis</h5>
<p>直角坐标系 grid 的 y 轴</p>
<h5 id="6polar"><a class="markdownIt-Anchor" href="#6polar">#</a> 6.polar</h5>
<p>极坐标系，可以用于散点图和折线图</p>
<h5 id="7radiusaxis"><a class="markdownIt-Anchor" href="#7radiusaxis">#</a> 7.radiusAxis</h5>
<p>极坐标系的径向轴</p>
<h5 id="8angleaxis"><a class="markdownIt-Anchor" href="#8angleaxis">#</a> 8.angleAxis</h5>
<p>极坐标系的角度轴</p>
<h5 id="9radar"><a class="markdownIt-Anchor" href="#9radar">#</a> 9.radar</h5>
<p>雷达图坐标系组件</p>
<h5 id="10datazoom"><a class="markdownIt-Anchor" href="#10datazoom">#</a> 10.dataZoom</h5>
<p>用于区域缩放</p>
<h5 id="11visualmap"><a class="markdownIt-Anchor" href="#11visualmap">#</a> 11.visualMap</h5>
<p>是视觉映射组件，用于进行『视觉编码』</p>
<h5 id="12tooltip"><a class="markdownIt-Anchor" href="#12tooltip">#</a> 12.tooltip</h5>
<p>提示框组件</p>
<h5 id="13axispointer"><a class="markdownIt-Anchor" href="#13axispointer">#</a> 13.axisPointer</h5>
<p>坐标轴指示器的全局公用设置</p>
<h5 id="14toolbox"><a class="markdownIt-Anchor" href="#14toolbox">#</a> 14.toolbox</h5>
<p>工具栏内置有导出图片、数据视图、动态类型转换、数据区域缩放、重置五个工具。</p>
<h5 id="15brush"><a class="markdownIt-Anchor" href="#15brush">#</a> 15.brush</h5>
<p><code>brush</code>  是区域选择组件，用户可以选择图中一部分数据，从而便于向用户展示被选中数据，或者他们的一些统计计算结果。</p>
<h5 id="16geo"><a class="markdownIt-Anchor" href="#16geo">#</a> 16.geo</h5>
<p>地理坐标系组件。地理坐标系组件用于地图的绘制，支持在地理坐标系上绘制<a href="https://echarts.apache.org/zh/option.html#series-scatter">散点图</a>，<a href="https://echarts.apache.org/zh/option.html#series-lines">线集</a>。</p>
<h5 id="17parallel"><a class="markdownIt-Anchor" href="#17parallel">#</a> 17.parallel</h5>
<p><a href="https://en.wikipedia.org/wiki/Parallel_coordinates">平行坐标系（Parallel Coordinates）</a> 是一种常用的可视化高维数据的图表</p>
<h5 id="18parallelaxis"><a class="markdownIt-Anchor" href="#18parallelaxis">#</a> 18.parallelAxis</h5>
<p>这个组件是平行坐标系中的坐标轴</p>
<h5 id="19singleaxis"><a class="markdownIt-Anchor" href="#19singleaxis">#</a> 19.singleAxis</h5>
<p>单轴。可以被应用到散点图中展现一维数据，</p>
<h5 id="20timeline"><a class="markdownIt-Anchor" href="#20timeline">#</a> 20.timeline</h5>
<p><code>timeline</code>  组件，提供了在多个 ECharts  <code>option</code>  间进行切换、播放等操作的功能</p>
<h5 id="21graphic"><a class="markdownIt-Anchor" href="#21graphic">#</a> 21.graphic</h5>
<p><code>graphic</code>  是原生图形元素组件。可以支持的图形元素包括：</p>
<p><a href="https://echarts.apache.org/zh/option.html#graphic.elements-image">image</a>, <a href="https://echarts.apache.org/zh/option.html#graphic.elements-text">text</a>, <a href="https://echarts.apache.org/zh/option.html#graphic.elements-circle">circle</a>, <a href="https://echarts.apache.org/zh/option.html#graphic.elements-sector">sector</a>, <a href="https://echarts.apache.org/zh/option.html#graphic.elements-ring">ring</a>, <a href="https://echarts.apache.org/zh/option.html#graphic.elements-polygon">polygon</a>, <a href="https://echarts.apache.org/zh/option.html#graphic.elements-polyline">polyline</a>, <a href="https://echarts.apache.org/zh/option.html#graphic.elements-rect">rect</a>, <a href="https://echarts.apache.org/zh/option.html#graphic.elements-line">line</a>, <a href="https://echarts.apache.org/zh/option.html#graphic.elements-bezierCurve">bezierCurve</a>, <a href="https://echarts.apache.org/zh/option.html#graphic.elements-arc">arc</a>, <a href="https://echarts.apache.org/zh/option.html#graphic.elements-group">group</a>,</p>
<h5 id="22calendar"><a class="markdownIt-Anchor" href="#22calendar">#</a> 22.calendar</h5>
<p>日历坐标系组件</p>
<h5 id="23dataset"><a class="markdownIt-Anchor" href="#23dataset">#</a> 23.dataset</h5>
<p>ECharts 4 开始支持了  <code>数据集</code> （ <code>dataset</code> ）组件用于单独的数据集声明，从而数据可以单独管理，被多个组件复用，并且可以自由指定数据到视觉的映射。这在不少场景下能带来使用上的方便。</p>
<h5 id="24aria"><a class="markdownIt-Anchor" href="#24aria">#</a> 24.aria</h5>
<p>W3C 制定了无障碍富互联网应用规范集（<a href="https://www.w3.org/WAI/intro/aria">WAI-ARIA</a>，the Accessible Rich Internet Applications Suite），致力于使得网页内容和网页应用能够被更多残障人士访问。</p>
<p>默认关闭，需要通过将 <a href="https://echarts.apache.org/zh/option.html#aria.enabled">aria.enabled</a> 设置为  <code>true</code>  开启。</p>
<h5 id="25series"><a class="markdownIt-Anchor" href="#25series">#</a> 25.series</h5>
<h5 id="26darkmode"><a class="markdownIt-Anchor" href="#26darkmode">#</a> 26.darkMode</h5>
<p>是否是暗黑模式，默认会根据背景色 <a href="https://echarts.apache.org/zh/option.html#backgroundColor">backgroundColor</a> 的亮度自动设置。 如果是设置了容器的背景色而无法判断到，就可以使用该配置手动指定，echarts 会根据是否是暗黑模式调整文本等的颜色。</p>
<h5 id="27color"><a class="markdownIt-Anchor" href="#27color">#</a> 27.color</h5>
<p>调色盘颜色列表。如果系列没有设置颜色，则会依次循环从该列表中取颜色作为系列颜色。</p>
<h5 id="28backgroundcolor"><a class="markdownIt-Anchor" href="#28backgroundcolor">#</a> 28.backgroundColor</h5>
<p>背景色，默认无背景。</p>
<h5 id="29textstyle"><a class="markdownIt-Anchor" href="#29textstyle">#</a> 29.textStyle</h5>
<p>全局的字体样式</p>
<h5 id="30animation"><a class="markdownIt-Anchor" href="#30animation">#</a> 30.animation</h5>
<p>是否开启动画</p>
<h5 id="31animationthreshold"><a class="markdownIt-Anchor" href="#31animationthreshold">#</a> 31.animationThreshold</h5>
<p>是否开启动画的阈值，当单个系列显示的图形数量大于这个阈值时会关闭动画。</p>
<h5 id="32animationduration"><a class="markdownIt-Anchor" href="#32animationduration">#</a> 32.animationDuration</h5>
<p>初始动画的时长，支持回调函数，可以通过每个数据返回不同的时长实现更戏剧的初始动画效果：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="attr">animationDuration</span>: <span class="keyword">function</span> (<span class="params">idx</span>) &#123;</span><br><span class="line">    <span class="comment">// 越往后的数据时长越大</span></span><br><span class="line">    <span class="keyword">return</span> idx * <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="33animationeasing"><a class="markdownIt-Anchor" href="#33animationeasing">#</a> 33.animationEasing</h5>
<p>初始动画的缓动效果。不同的缓动效果可以参考 <a href="https://echarts.apache.org/examples/zh/editor.html?c=line-easing">缓动示例</a>。</p>
<h5 id="34animationdelay"><a class="markdownIt-Anchor" href="#34animationdelay">#</a> 34.animationDelay</h5>
<p>初始动画的延迟，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的初始动画效果。</p>
<p>如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="attr">animationDelay</span>: <span class="keyword">function</span> (<span class="params">idx</span>) &#123;</span><br><span class="line">    <span class="comment">// 越往后的数据延迟越大</span></span><br><span class="line">    <span class="keyword">return</span> idx * <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="35animationdurationupdate"><a class="markdownIt-Anchor" href="#35animationdurationupdate">#</a> 35.animationDurationUpdate</h5>
<p>数据更新动画的时长。</p>
<p>支持回调函数，可以通过每个数据返回不同的时长实现更戏剧的更新动画效果：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="attr">animationDurationUpdate</span>: <span class="keyword">function</span> (<span class="params">idx</span>) &#123;</span><br><span class="line">    <span class="comment">// 越往后的数据时长越大</span></span><br><span class="line">    <span class="keyword">return</span> idx * <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="36animationeasingupdate"><a class="markdownIt-Anchor" href="#36animationeasingupdate">#</a> 36.animationEasingUpdate</h5>
<p>数据更新动画的缓动效果。</p>
<h5 id="37animationdelayupdate"><a class="markdownIt-Anchor" href="#37animationdelayupdate">#</a> 37.animationDelayUpdate</h5>
<p>数据更新动画的延迟，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的更新动画效果。</p>
<p>如下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="attr">animationDelayUpdate</span>: <span class="keyword">function</span> (<span class="params">idx</span>) &#123;</span><br><span class="line">    <span class="comment">// 越往后的数据延迟越大</span></span><br><span class="line">    <span class="keyword">return</span> idx * <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以看<a href="https://echarts.apache.org/examples/zh/editor.html?c=bar-animation-delay">该示例</a></p>
<h5 id="38stateanimation"><a class="markdownIt-Anchor" href="#38stateanimation">#</a> 38.stateAnimation</h5>
<p>状态切换的动画配置，支持在每个系列里设置单独针对该系列的配置。</p>
<h5 id="39blendmode"><a class="markdownIt-Anchor" href="#39blendmode">#</a> 39.blendMode</h5>
<p>图形的混合模式，不同的混合模式见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation">https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation</a> 。</p>
<p>默认为  <code>'source-over'</code> 。 支持每个系列单独设置。</p>
<p><code>'lighter'</code>  也是比较常见的一种混合模式，该模式下图形数量集中的区域会颜色叠加成高亮度的颜色（白色）。常常能起到突出该区域的效果。见示例 <a href="https://echarts.apache.org/examples/zh/editor.html?c=lines-airline">全球飞行航线</a></p>
<h5 id="40hoverlayerthreshold"><a class="markdownIt-Anchor" href="#40hoverlayerthreshold">#</a> 40.hoverLayerThreshold</h5>
<p>图形数量阈值，决定是否开启单独的 hover 层，在整个图表的图形数量大于该阈值时开启单独的 hover 层。</p>
<p>单独的 hover 层主要是为了在高亮图形的时候不需要重绘整个图表，只需要把高亮的图形放入单独的一个 canvas 层进行绘制，防止在图形数量很多的时候因为高亮重绘所有图形导致卡顿。</p>
<p>ECharts 2 里是底层强制使用单独的层绘制高亮图形，但是会带来很多问题，比如高亮的图形可能会不正确的遮挡所有其它图形，还有图形有透明度因为高亮和正常图形叠加导致不正确的透明度显示，还有移动端上因为每个图表都要多一个 canvas 带来的额外内存开销。因此 3 里默认不会开启该优化，只有在图形数量特别多，有必要做该优化时才会自动开启。</p>
<h5 id="41useutc"><a class="markdownIt-Anchor" href="#41useutc">#</a> 41.useUTC</h5>
<p>是否使用 UTC 时间。</p>
<ul>
<li><code>true</code> : 表示  <code>axis.type</code>  为  <code>'time'</code>  时，依据 UTC 时间确定 tick 位置，并且  <code>axisLabel</code>  和  <code>tooltip</code>  默认展示的是 UTC 时间。</li>
<li><code>false</code> : 表示  <code>axis.type</code>  为  <code>'time'</code>  时，依据本地时间确定 tick 位置，并且  <code>axisLabel</code>  和  <code>tooltip</code>  默认展示的是本地时间。</li>
</ul>
<p>默认取值为 false，即使用本地时间。因为考虑到：</p>
<ul>
<li>很多情况下，需要展示为本地时间（无论服务器存储的是否为  <code>UTC</code>  时间）。</li>
<li>如果 data 中的时间为 ‘2012-01-02’ 这样的没有指定时区的时间表达式，往往意为本地时间。默认情况下，时间被展示时需要和输入一致而非有时差。</li>
</ul>
<p>注意，这个参数实际影响的是『展示』，而非用户输入的时间值的解析。 关于用户输入的时间值（例如  <code>1491339540396</code> ,  <code>'2013-01-04'</code>  等）的解析，参见 <a href="https://echarts.apache.org/zh/option.html#series-line.data">date 中时间相关部分</a>。</p>
<h5 id="42options"><a class="markdownIt-Anchor" href="#42options">#</a> 42.options</h5>
<p>用于 <a href="https://echarts.apache.org/zh/option.html#timeline">timeline</a> 的 option 数组。数组的每一项是一个 echarts option ( <code>ECUnitOption</code> )。</p>
<h5 id="43media"><a class="markdownIt-Anchor" href="#43media">#</a> 43.media</h5>
<p>请参见 <a href="https://echarts.apache.org/zh/tutorial.html#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94">移动端自适应</a>。</p>
]]></content>
  </entry>
  <entry>
    <title>hexo使用</title>
    <url>/2022/07/07/hexo%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="1准备"><a class="markdownIt-Anchor" href="#1准备">#</a> 1. 准备</h4>
<p>输入代码时，核对准确，最好切换成英文输入法；</p>
<p>将文中的 “用户名” 和 “邮箱” 替换为自己的 GitHub 账户名和绑定的邮箱；</p>
<p>统一使用 Git Bash 进行操作 (支持 Win、Mac、Linux)；</p>
<p>每次修改后都需要运行 hexo g 和 hexo d 使其生效；</p>
<p>小白请严格按步骤进行，不要跳！</p>
<h4 id="2环境搭建"><a class="markdownIt-Anchor" href="#2环境搭建">#</a> 2. 环境搭建</h4>
<h5 id="1环境"><a class="markdownIt-Anchor" href="#1环境">#</a> 1. 环境</h5>
<p>Hexo 基于 Node.js，搭建过程中还需要使用 npm 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。</p>
<p>Node.js：<a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></p>
<p>Git：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
<p>下载 Node.js 和 Git 程序并安装。Node.js 默认安装 npm，一路点 “下一步” 按默认配置完成安装。</p>
<p>安装完成后，Win+R 输入 cmd 并打开，依次输入 node -v、npm -v 和 git --version 并回车，如下图出现程序版本号即可。</p>
<ol start="2">
<li>
<h5 id="连接-github"><a class="markdownIt-Anchor" href="#连接-github">#</a> 连接 Github</h5>
</li>
</ol>
<p>使用邮箱注册 GitHub 账户，选择免费账户 (Free)，并完成邮件验证。</p>
<p>右键 -&gt; Git Bash Here，设置用户名和邮箱：</p>
<p>git config --global <a href="http://user.name">user.name</a> &quot;GitHub 用户名&quot;git config --global user.email “GitHub 邮箱”<br>
 创建 SSH 密匙，输入 ssh-keygen -t rsa -C “GitHub 邮箱”，然后一路回车。密匙生成位置在 C:\Users\ 用户名.ssh 目录下 (要勾选显示 “隐藏的项目” 选项)。</p>
<p>登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key，添加密匙：</p>
<p>Title 随便取个名字，用记事本打开公钥 id_rsa.pub 复制里面的内容，粘贴到 Key 中，点击 Add SSH key 完成添加。</p>
<p>验证连接：打开 Git Bash，输入 ssh -T <a href="mailto:git@github.com">git@github.com</a> 出现 “Are you sure……”，输入 yes 回车确认。</p>
<p>显示 “Hi xxx! You’ve successfully authenticated……” 即连接成功。</p>
<ol start="3">
<li>
<h5 id="创建-github-pages-仓库"><a class="markdownIt-Anchor" href="#创建-github-pages-仓库">#</a> 创建 Github Pages 仓库</h5>
</li>
</ol>
<p>GitHub 主页右上角加号 -&gt; New repository：</p>
<p>Repository name 中输入 <a href="http://xn--eqr924avxo.github.io">用户名.github.io</a></p>
<p>勾选 “Initialize this……”</p>
<p>Description 选填</p>
<p>填好后点击 Create repository 创建。</p>
<p>创建后默认自动启用 HTTPS，博客地址为：<a href="https://xn--eqr924avxo.github.io">https:// 用户名.github.io</a></p>
<ol start="4">
<li>
<h5 id="本地安装-hexo-博客程序"><a class="markdownIt-Anchor" href="#本地安装-hexo-博客程序">#</a> 本地安装 Hexo 博客程序</h5>
</li>
</ol>
<p>新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog。打开该文件夹，右键 -&gt; Git Bash Here。</p>
<h4 id="3-安装-hexo"><a class="markdownIt-Anchor" href="#3-安装-hexo">#</a> 3. 安装 Hexo</h4>
<p>使用 npm 一键安装 Hexo 博客程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>Mac 用户需要管理员权限 (sudo)，运行这条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h4 id="4-hexo-初始化和本地预览"><a class="markdownIt-Anchor" href="#4-hexo-初始化和本地预览">#</a> 4 Hexo 初始化和本地预览</h4>
<p>输入 hexo init 进行初始化，显示 “Start blogging with Hexo!”，然后运行 npm install 安装所需组件。</p>
<p>完成后依次输入下面命令，启动本地服务器进行预览：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g # 生成页面</span><br><span class="line">hexo s # 启动预览</span><br></pre></td></tr></table></figure>
<p>访问 <a href="http://localhost:4000">http://localhost:4000</a>，出现 Hexo 默认页面，本地博客安装成功！</p>
<p>Tips：如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 hexo server -p 5000 更改端口号后重试。</p>
<p>部署 Hexo 到 GitHub Pages 本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。</p>
<p>首先安装 hexo-deployer-git：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy</span>:</span><br><span class="line">  <span class="attr">type</span>: git</span><br><span class="line">  <span class="attr">repo</span>: git@github.<span class="property">com</span>:menglixunni/menglixunni.<span class="property">github</span>.<span class="property">io</span>.<span class="property">git</span></span><br><span class="line">  <span class="attr">branch</span>: master</span><br></pre></td></tr></table></figure>
<p>完成后运行 hexo d 将网站上传部署到 GitHub Pages。完成！这时访问我们的 GitHub 域名 <a href="https://xn--eqr924avxo.github.io">https:// 用户名.github.io</a> 就可以看到 Hexo 网站了。</p>
<h4 id="5-发布文章"><a class="markdownIt-Anchor" href="#5-发布文章">#</a> 5. 发布文章</h4>
<p>进入博客所在目录，右键打开 Git Bash Here，创建博文：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后 source 文件夹中会出现一个 My New <a href="http://Post.md">Post.md</a> 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。</p>
<p>写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。以后每次发布文章都是这两条命令。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo g  <span class="comment">//部署到本地</span></span><br><span class="line">hexo d  <span class="comment">//部署到github</span></span><br></pre></td></tr></table></figure>
<p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 hexo g 和 hexo d 发布。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---title: Hello World # 标题</span><br><span class="line">date: 2019/3/26 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类- Diarytags: # 标签</span><br><span class="line">- PS3- Games---摘要正文</span><br></pre></td></tr></table></figure>
<h4 id="6网站设置"><a class="markdownIt-Anchor" href="#6网站设置">#</a> 6. 网站设置</h4>
<p>包括网站名称、描述、作者、链接样式等，全部在网站目录下的 _config.yml 文件中，参考官方文档按需要编辑。</p>
<p>注意：冒号后要加一个空格！</p>
<h4 id="7-更换主题"><a class="markdownIt-Anchor" href="#7-更换主题">#</a> 7. 更换主题</h4>
<p>在 Themes | Hexo 选择一个喜欢的主题，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//hexo.io/themes/index.html</span></span><br></pre></td></tr></table></figure>
<p>然后修改 _config.yml 中的 theme 为新主题名称 next，发布。(有的主题需要将 _config.yml 替换为主题自带的，参考主题说明。)</p>
<h4 id="8常用命令"><a class="markdownIt-Anchor" href="#8常用命令">#</a> 8. 常用命令</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&#x27;名字&#x27;</span> <span class="comment">//创建新文件</span></span><br><span class="line">hexo clean <span class="comment">//清除</span></span><br><span class="line">hexo g <span class="comment">//部署本地</span></span><br><span class="line">hexo s <span class="comment">//本地启动</span></span><br><span class="line">hexo d <span class="comment">//上传到github</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2学习</title>
    <url>/2022/07/07/vue2%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="1vue模板语法"><a class="markdownIt-Anchor" href="#1vue模板语法">#</a> 1.Vue 模板语法</h4>
<p>​	1. 插值语法：</p>
<p>​		功能：用于解析标签体内容</p>
<p>​		写法：，xxx 是 js 表达式，且可以直接读取到 data 中的所有属性</p>
<p>​		v-once：执行一次性的插值，数据改变时，插值处的内容也不会更新。</p>
<p>​		v-html：输出 html</p>
<p>​	2. 指令语法：</p>
<p>​		功能：用于解析标签</p>
<p>​		举例：v-bind:href =“xxx” 或简写为 :href=“xxx”，xxx 是 js 表达式，且可以直接读取到 data 中的所有属性</p>
<h4 id="2vue数据绑定"><a class="markdownIt-Anchor" href="#2vue数据绑定">#</a> 2.Vue 数据绑定</h4>
<p>​	1. 单向数据绑定（v-bind）: 数据只能从 data 流向页面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>​	如果  <code>isButtonDisabled</code>  的值是  <code>null</code> 、 <code>undefined</code>  或  <code>false</code> ，则  <code>disabled</code>  attribute 甚至不会被包含在渲染出来的  <code>&lt;button&gt;</code>  元素中。</p>
<p>​	v-bind 缩写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​	2. 双向数据绑定（v-model）: 数据不仅能从 data 流向页面，还可以从页面流向 data。</p>
<p>​		备注：双向数据绑定一般用在表单元素上（input，select）</p>
<p>​					v-model：value 可以简写为 v-model</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;root&quot;</span>&gt;</span><br><span class="line">			单向数据绑定:<span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line">			&lt;!-- v-model只能用在表单类的元素中 --&gt;</span><br><span class="line">			双向数据绑定:<span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model:value</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3vue事件的基本使用"><a class="markdownIt-Anchor" href="#3vue事件的基本使用">#</a> 3.Vue 事件的基本使用</h4>
<p>​	1.v-on：xxx 或 @xxx 绑定事件，xxx 是事件名</p>
<p>​		v-on 缩写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 动态参数的缩写 (<span class="number">2.6</span><span class="number">.0</span>+) --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>​	2. 事件的回调需要配置在 methods 对象中，最终会在 vm 上</p>
<p>​	3.methods 中配置的函数，不要使用箭头函数！否则 this 就不是 vm 了</p>
<p>​	4.methods 中配置的函数，都是被 Vue 所管理的函数，this 的指向是 vm 或组件实例对象</p>
<p>​	5.@click=“demo” 和 @click =“demo ($event)” 效果一直，但后者可以传参数</p>
<h4 id="4vue事件修饰符"><a class="markdownIt-Anchor" href="#4vue事件修饰符">#</a> 4.Vue 事件修饰符</h4>
<p>​	1.prevent: 阻止默认事件</p>
<p>​	2.stop：阻止事件冒泡</p>
<p>​	3.once : 事件只出发一次</p>
<p>​	4.capture: 使用事件的捕获模式</p>
<p>​	5.self: 只有 event.target 是当前操作的元素时才会触发事件</p>
<p>​	6. passive: 事件的默认行为立即执行，无需等待事件回调执行完毕。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;root&quot;</span>&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>你是我的&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">	&lt;!-- 阻止默认事件prvent --&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.atguigu.com&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;showInfo1&quot;</span>&gt;</span>点我跳转网址<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">	&lt;!-- 阻止事件冒泡 stop --&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo1&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;showInfo2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;showInfo2&quot;</span>&gt;</span>点我提示信息1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	&lt;!-- 事件只触发一次 once --&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.once</span>=<span class="string">&quot;showInfo2&quot;</span>&gt;</span>点我提示信息2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">	&lt;!-- 使用事件捕获方式 capture--&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span> @<span class="attr">click.capture</span>=<span class="string">&quot;showMsg(1)&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		div1</span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;showMsg(2)&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			div2</span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	&lt;!-- self 只有event.<span class="property">target</span>是当前元素操作时才触发事件--&gt;</span><br><span class="line">	&lt;!-- <span class="attr">passive</span>:事件的默认行为立即执行，无需等待事件回调执行完毕 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h4 id="5vue中常用的按键别名"><a class="markdownIt-Anchor" href="#5vue中常用的按键别名">#</a> 5.Vue 中常用的按键别名</h4>
<p>​	1. 回车 =&gt;enter、删除 =&gt;delete (捕获 “删除” 和 “退格” 键)、退出 =&gt;esc、空格 =&gt;space、换行 =&gt;tab (特殊，必须配合 keydown 去使用)、</p>
<p>​	上 =&gt;up、下 =&gt;down、左 =&gt;left、右 =&gt;right</p>
<p>​	2.Vue 未提供别名的按键，可以使用按键原始的 key 值去绑定，但注意要转化为 kebab-case（短横线命名）</p>
<p>​	3. 系统修饰键（用法特殊）：ctrl、alt、shift、meta</p>
<p>​		（1）. 配合 keyup 使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发</p>
<p>​		（2）. 配合 keydown 使用：正常触发事件</p>
<p>​	4. 可以使用 keyCode 去指定具体的按键（不推荐）</p>
<p>​	5.Vue.fonfig.keyCodes. 自定义键名 = 键码，可以去定制按键别名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;root&quot;</span>&gt;</span><br><span class="line">			<span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>你是我的&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">			<span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;按下回车提示输入&quot;</span> @<span class="attr">keyup</span>=<span class="string">&quot;showInfo()&quot;</span>/&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h4 id="6vue计算属性"><a class="markdownIt-Anchor" href="#6vue计算属性">#</a> 6.Vue 计算属性</h4>
<p>​	1. 定义：要用的属性不存在，要通过自己已有的属性计算得出。</p>
<p>​	2. 原理：底层借助了 Object.defineproperty 方法提供的 getter 和 setter</p>
<p>​	3.get 函数什么时候执行</p>
<p>​		初次读取的时候执行一次</p>
<p>​		当依赖的数据发声变化时会再次被调用</p>
<p>​	4. 优势：与 methods 实现相比，内部有缓存机制（复用），效率更高，调试更方便。</p>
<p>​	5. 备注：</p>
<p>​		1，计算属性最终会出现在 vm 上，直接读取使用即可。</p>
<p>​		2. 如果计算属性要被修改，必须写 set 函数去相应修改，且 set 中要引起计算时依赖的数据发声改变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;root&quot;</span>&gt;</span><br><span class="line">			姓：&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;firstName&quot;</span>/&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line">			名：&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;lastName&quot;</span>/&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line">			姓名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">				<span class="comment">//完整写法</span></span><br><span class="line">				<span class="comment">// fullName:&#123;</span></span><br><span class="line">				<span class="comment">// 	//读取时使用一次，所有依赖数据发生变化时读取一次</span></span><br><span class="line">				<span class="comment">// 	get()&#123;</span></span><br><span class="line">				<span class="comment">// 		return this.firstName + &#x27;-&#x27; + this.lastName</span></span><br><span class="line">				<span class="comment">// 	&#125;,</span></span><br><span class="line">				<span class="comment">// 	set(value)&#123;</span></span><br><span class="line">				<span class="comment">// 		const arr = value.split(&#x27;-&#x27;)</span></span><br><span class="line">				<span class="comment">// 		this.firstName = arr[0]</span></span><br><span class="line">				<span class="comment">// 		this.lastName = arr[1]</span></span><br><span class="line">				<span class="comment">// 	&#125;</span></span><br><span class="line">				<span class="comment">// &#125;,</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">//简写，只考虑读取的时候</span></span><br><span class="line">				<span class="comment">// fullName()&#123;</span></span><br><span class="line">				<span class="comment">// 	return this.firstName + &#x27;-&#x27; + this.lastName</span></span><br><span class="line">				<span class="comment">// &#125;</span></span><br><span class="line">			&#125;,</span><br></pre></td></tr></table></figure>
<h4 id="7vue监听属性"><a class="markdownIt-Anchor" href="#7vue监听属性">#</a> 7.Vue 监听属性</h4>
<p>​	1. 当被监视的属性发声变化时，回调函数自动调用，进行相关操作</p>
<p>​	2. 监视的属性必须存在，才能进行监视</p>
<p>​	3. 监视的两种写法：</p>
<p>​		（1）new Vue 时传入 watch 配置</p>
<p>​		（2）通过 vm.watch 监视</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;root&quot;</span>&gt;</span><br><span class="line">			<span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span> 今天天气很好&#123;&#123;info&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">			<span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeWeather&quot;</span>&gt;</span>切换天气<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">			<span class="attr">el</span>: <span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">			<span class="attr">data</span>: &#123;</span><br><span class="line">				<span class="attr">isHot</span>: <span class="literal">true</span>,	</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">computed</span>: &#123;</span><br><span class="line">			<span class="title function_">info</span>(<span class="params"></span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">isHot</span> ? <span class="string">&#x27;炎热&#x27;</span> : <span class="string">&#x27;凉爽&#x27;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">methods</span>: &#123;</span><br><span class="line">			<span class="title function_">changeWeather</span>(<span class="params"></span>) &#123;</span><br><span class="line">				<span class="variable language_">this</span>.<span class="property">isHot</span> = !<span class="variable language_">this</span>.<span class="property">isHot</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">watch</span>: &#123;</span><br><span class="line">			<span class="comment">// 完整写法</span></span><br><span class="line">			<span class="comment">// isHot: &#123;</span></span><br><span class="line">			<span class="comment">// 	immediate:true //初始化时让handler调用</span></span><br><span class="line">			<span class="comment">// 	deep:true</span></span><br><span class="line">			<span class="comment">// 	handlder(newValue, oldValue) &#123;</span></span><br><span class="line">			<span class="comment">// 		console.log(&quot;isHot被修改了&quot;,newValue, oldValue)</span></span><br><span class="line">			<span class="comment">// 	&#125;</span></span><br><span class="line">			<span class="comment">// &#125;,</span></span><br><span class="line">			<span class="comment">//简写</span></span><br><span class="line">			<span class="title function_">isHot</span>(<span class="params">newVaule, oldValue</span>)&#123;</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;isHot被修改了&quot;</span>,newValue, oldValue)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正常写法</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;isHot&#x27;</span>, &#123;</span><br><span class="line">	<span class="attr">immediate</span>:<span class="literal">true</span>,</span><br><span class="line">	<span class="attr">deep</span>:<span class="literal">true</span>,</span><br><span class="line">	<span class="title function_">handlder</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;isHot被修改了&quot;</span>,newValue, oldValue)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//简写</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;isHot&#x27;</span>, <span class="keyword">function</span>(<span class="params">newValue, oldValue</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;isHot被修改了&quot;</span>,newValue, oldValue)</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
<p>4. 深度监视</p>
<p>​	（1）Vue 中的 watch 默认不监测对象内部值的改变（一层）</p>
<p>​	（2）配置 deep：true 可以监测对象内部值改变（多层）</p>
<p>​	注意：</p>
<p>​	（1）Vue 自身可以监测对象内部值的改变，但 Vue 提供的 watch 默认不可以</p>
<p>​	（2）使用 watch 时根据数据的具体结构，决定是否采用深度监视</p>
<p>5.computed 和 watch 之间的区别</p>
<p>​	（1）computed 能完成的功能，watch 都可以完成</p>
<p>​	（2）watch 能完成的功能，computed 不一定能完成，例如：watch 可以进行异步操作‘，开销大的操作也要放在 watch 里，</p>
<p>​	小原则：</p>
<p>​	（1）所被 Vue 管理的函数，最好写成普通函数，这样 this 的指向才是 vm 或组件实例对象。</p>
<p>​	（2）所有不被 Vue 所管理的函数（定时器的回调函数、ajax 的回调函数等、Promise 的回调函数），最好写成箭头函数，这样 this 的指向才是 vm 或组件实例对象。</p>
<h4 id="8vue绑定样式"><a class="markdownIt-Anchor" href="#8vue绑定样式">#</a> 8.Vue 绑定样式</h4>
<p>​	1.class 样式</p>
<p>​		写法：class=“xxx” xxx 可以是字符串、对象、数组</p>
<p>​		字符串写法适用于：类名不确定，要 动态获取。</p>
<p>​		对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。</p>
<p>​		数组写法使用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</p>
<p>​	2.style 样式</p>
<p>​		：style=&quot;{fontSize：xxx}&quot; 其中 XXX 是动态值</p>
<p>​		：style=&quot;[a,b]&quot; 其中 a、b 是样式对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;root&quot;</span>&gt;</span><br><span class="line">	&lt;!-- 绑定<span class="keyword">class</span>样式，字符串写法，适用于要绑定的样式类名不确定，，需要动态绑定--&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;mood&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeMood&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line">		&lt;!-- 绑定<span class="keyword">class</span>样式，数组写法，适用于要绑定的样式个数不确定，名字也不确定 --&gt;</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;classArr&quot;</span> &gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line">		&lt;!-- 绑定<span class="keyword">class</span>样式，对象写法，适用于要绑定的样式个数确定，名字夜确定，但是要动态决定用不用 --&gt;</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;classObj&quot;</span> &gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h4 id="9vue列表渲染-v-for"><a class="markdownIt-Anchor" href="#9vue列表渲染-v-for">#</a> 9.Vue 列表渲染 v-for</h4>
<p>​	1. 用于展示列表数据</p>
<p>​	2. 语法：v-for = “(item, index) in xxx” :key=“yyy”</p>
<p>​	3. 可以遍历：数据、对象、字符串、指定次数</p>
<p><img src="C:%5CUsers%5C17281%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220412150110917.png" alt="image-20220412150110917"></p>
<h4 id="10vue表单"><a class="markdownIt-Anchor" href="#10vue表单">#</a> 10.vue 表单</h4>
<p>​	收集表单数据：</p>
<pre><code>若：&lt;input type=&quot;text&quot;/&gt;，则v-model收集的事value值，用户输入的就是value值。
</code></pre>
<p>​		若： <input type="radio"/>，则 v-model 收集的事 value 值，且要给标签配置 value 值。</p>
<p>​		若：<input type="checkbox"/>，</p>
<p>​				1. 没有配置 input 的 value 属性，那么收集的就是 checked（勾选或未勾选，是布尔值）</p>
<p>​				2. 配置 input 的 value 属性：</p>
<p>​				（1）v-model 的初始值是非数组，那么收集的就是 checked（勾选或未勾选，是布尔值）</p>
<p>​				（2）v-model 的初始值是数组，那么收集的就是 value 组成的数组</p>
<p>​	备注：v-model 的三个修饰符 type=‘’</p>
<p>​				lazy：失去焦点时再收集数据</p>
<p>​				number：输入字符串转为有效的数字</p>
<p>​				trim：输入首位空格过滤</p>
<h4 id="11vue过滤器"><a class="markdownIt-Anchor" href="#11vue过滤器">#</a> 11.vue 过滤器</h4>
<p>​	过滤器</p>
<p>​		定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）</p>
<p>​		语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	1.注册过滤器：Vue.filter(name,callback)  或 new Vue&#123;filter:&#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">​			2.使用过滤器：&#123;&#123;xxx|过滤器名&#125;&#125; 或 v-bind:属性 = &quot;xxx|过滤器名&quot;</span><br><span class="line"></span><br><span class="line">​		备注：</span><br><span class="line"></span><br><span class="line">​			1.过滤器也可以接受额外的参数、多个过滤器也可以串联</span><br><span class="line"></span><br><span class="line">​			2.并没有改变原本的数据，是产生新的对应的数据</span><br></pre></td></tr></table></figure>
<h4 id="12vue内置指令"><a class="markdownIt-Anchor" href="#12vue内置指令">#</a> 12.vue 内置指令</h4>
<h5 id="v-bind-单向绑定解析表达式可以简写为xxx可以绑定三元运算符-绑定true和false"><a class="markdownIt-Anchor" href="#v-bind-单向绑定解析表达式可以简写为xxx可以绑定三元运算符-绑定true和false">#</a> v-bind : 单向绑定解析表达式，可以简写为：XXX，可以绑定三元运算符、绑定 true 和 false</h5>
<h5 id="v-model双向数据绑定"><a class="markdownIt-Anchor" href="#v-model双向数据绑定">#</a> v-model：双向数据绑定</h5>
<h5 id="v-for遍历数组-对象-字符串"><a class="markdownIt-Anchor" href="#v-for遍历数组-对象-字符串">#</a> v-for：遍历数组、对象、字符串</h5>
<h5 id="v-on绑定事件监听可以简写为"><a class="markdownIt-Anchor" href="#v-on绑定事件监听可以简写为">#</a> v-on：绑定事件监听，可以简写为 @</h5>
<h5 id="v-if条件渲染动态控制节点是否存在"><a class="markdownIt-Anchor" href="#v-if条件渲染动态控制节点是否存在">#</a> v-if：条件渲染（动态控制节点是否存在）</h5>
<h5 id="v-else条件渲染动态控制节点是否存在"><a class="markdownIt-Anchor" href="#v-else条件渲染动态控制节点是否存在">#</a> v-else：条件渲染（动态控制节点是否存在）</h5>
<h5 id="v-show条件渲染动态控制节点是否展示"><a class="markdownIt-Anchor" href="#v-show条件渲染动态控制节点是否展示">#</a> v-show：条件渲染（动态控制节点是否展示）</h5>
<h5 id="v-pre-跳过这个元素和他子元素的编译"><a class="markdownIt-Anchor" href="#v-pre-跳过这个元素和他子元素的编译">#</a> v-pre 跳过这个元素和他子元素的编译</h5>
<h5 id="v-html指令"><a class="markdownIt-Anchor" href="#v-html指令">#</a> v-html 指令：</h5>
<p>​	1. 作用：向指定节点中渲染包含 html 结构的内容</p>
<p>​	2. 与插值语法的区别：</p>
<p>​		（1）v-html 会替换掉节点中所有的内容，则不会</p>
<p>​		（2）v-html 可以识别 html 结构。</p>
<p>​	3. 严重注意：v-html 有安全性问题！！！</p>
<p>​	（1）. 在网站上动态渲染任意 html 是非常危险的，容易导致 XSS 攻击。</p>
<p>​	（2）. 一定要在可信的内容上使用 v-html，水不要用在用户提交的内容上！</p>
<h5 id="v-cloak指令没有值"><a class="markdownIt-Anchor" href="#v-cloak指令没有值">#</a> v-cloak 指令（没有值）</h5>
<p>​	1. 本质是一个特殊属性，Vue 实例创建完毕并接管容器后，会删除掉 v-cloak 属性</p>
<p>​	2. 使用 css 配合 v-clock 可以解决网速慢时页面展示出的问题。</p>
<h5 id="v-once指令"><a class="markdownIt-Anchor" href="#v-once指令">#</a> v-once 指令</h5>
<p>​	1.v-once 所在节点在初次动态渲染后，就会视为静态内容</p>
<p>​	2. 以后数据的改变不会引起 v-once 所在结构的更新，可以用于优化性能。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;myonce&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-once</span>&gt;</span>初始化的n值：&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前的n值：&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;n++&quot;</span>&gt;</span>点我加加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="v-pre指令"><a class="markdownIt-Anchor" href="#v-pre指令">#</a> v-pre 指令</h5>
<p>​	1. 跳过起所在节点的编译过程。</p>
<p>​	2. 可利用它跳过：没有使用指令语法，没有使用插值语法的节点，会加快编译。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;my2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-pre</span>&gt;</span>初始化的n值：心烦意乱 m是0<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-pre</span>&gt;</span>当前的n值：&#123;&#123;m&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>  @<span class="attr">click</span>=<span class="string">&quot;m++&quot;</span>&gt;</span>点我加加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="13自定义指令"><a class="markdownIt-Anchor" href="#13自定义指令">#</a> 13. 自定义指令</h4>
<p>一、定义语法：</p>
<p>​	（1）局部指令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	<span class="attr">directives</span>:&#123;指令名：配置对象&#125;</span><br><span class="line">&#125;)</span><br><span class="line">或</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	<span class="title function_">directives</span>(<span class="params"></span>)&#123;指令名：配置对象&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>​	（2）全局指令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directives</span>(指令名，配置对象)或 </span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(指令名，回调函数)</span><br></pre></td></tr></table></figure>
<p>二、配置对象中常用的 3 个回调：</p>
<p>​	（1）bind ：指令与元素成功绑定时调用</p>
<p>​	（2）inserted：指令所在元素被插入页面时调用</p>
<p>​	（3）update：指令所在模板结构被重新解析时调用</p>
<p>三、备注：</p>
<p>​	1. 指令定义时不加 v-，但使用时要加 v-：</p>
<p>​	2. 指令名如果是多个单词，要使用 kebab-case 命名方式，不要用 camelCase 命名 14</p>
<h4 id="14生命周期"><a class="markdownIt-Anchor" href="#14生命周期">#</a> 14. 生命周期</h4>
<p>vm 的生命周期和人的一生相似：</p>
<p>​	beforeCreate：将要创建，形成受精卵之前</p>
<p>​	created：创建完成，形成受精卵</p>
<p>​	beforeMount：将要挂载，受精卵发育开始形成眼睛，鼻子，胳膊，腿等</p>
<p>​	mounted：挂载完成，受精卵发育完成，形成一个婴儿</p>
<p>​	beforeUpdate：将要更新，学习一切新东西</p>
<p>​	updated：更新完毕，东西都学会了，</p>
<p>​	beforeDestroy：将要销毁，将要永别，交代后事</p>
<p>​	destroyed：被销毁，去世。</p>
<p><img src="C:%5CUsers%5C17281%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220404153044364.png" alt="image-20220404153044364"></p>
<p>常用的生命周期钩子：</p>
<p>​	1.mounted：发送 ajax 请求、启动定时器、绑定自定义事件、订阅消息等 {初始化操作}。</p>
<p>​	2.beforeDestroy：清除定时器、解绑自定义事件、取消订阅消息等 {收尾工作}。</p>
<p>关于销毁 Vue 实例</p>
<p>​	1. 销毁后借助 Vue 开发者工具看不到任何信息。</p>
<p>​	2. 销毁后自定义事件会失效，但原生 DOM 事件依然有效。</p>
<p>​	3. 一般不会再 beforeDestroy 操作数据，因为即便操作数据，也不会再触发更新流程了。</p>
<h4 id="15vue组件"><a class="markdownIt-Anchor" href="#15vue组件">#</a> 15.Vue 组件</h4>
<p>​	非单文件组件：</p>
<p>​			一个文件中包含 n 个组件</p>
<p>​	单文件组件：</p>
<p>​			一个文件中包含有 1 个组件</p>
<p>​	1. 关于组件名：</p>
<p>​			一个单词组成：</p>
<p>​					第一种写法（首字母小写）：school</p>
<p>​					第二种写法（首字母大写）：School</p>
<p>​			多个单词组成：</p>
<p>​					第一种写法（kebab-case 命名）：my-school</p>
<p>​					第二种写法（CamelCase 命名）：MySchool（需要 Vue 脚手架支持）</p>
<p>​	2. 关于组件标签：</p>
<p>​		第一种写法：<school></school></p>
<p>​		第二种写法：<school/></p>
<p>​		备注：不用使用脚手架时，<school/>会导致后续组件不能渲染。</p>
<p>​	3. 一个简写方式：</p>
<p>​		const school = Vue.extend (options) 可简写为：const  school  = options</p>
<h4 id="16vuecomponent"><a class="markdownIt-Anchor" href="#16vuecomponent">#</a> 16.VueComponent</h4>
<h5 id="1school组件本质是一个名为vuecomponent的构造函数且不是程序员定义的是vueextend生成的"><a class="markdownIt-Anchor" href="#1school组件本质是一个名为vuecomponent的构造函数且不是程序员定义的是vueextend生成的">#</a> 1.school 组件本质是一个名为 VueComponent 的构造函数，且不是程序员定义的，是 Vue.extend 生成的。</h5>
<h5 id="2我们只需要写school或schoolschoolvue解析时会帮我们创建school组件的实例对象"><a class="markdownIt-Anchor" href="#2我们只需要写school或schoolschoolvue解析时会帮我们创建school组件的实例对象">#</a> 2. 我们只需要写<school/>或<school></school>.Vue 解析时会帮我们创建 school 组件的实例对象。</h5>
<h5 id="3特别注意每次调用vueextend返回的都是一个全新的vuecomponent"><a class="markdownIt-Anchor" href="#3特别注意每次调用vueextend返回的都是一个全新的vuecomponent">#</a> 3. 特别注意：每次调用 Vue.extend. 返回的都是一个全新的 VueComponent！！！！</h5>
<h5 id="4关于this指向"><a class="markdownIt-Anchor" href="#4关于this指向">#</a> 4. 关于 this 指向：</h5>
<p>​		（1）. 组件配置中：</p>
<p VueComponent实例对象="">​				data 函数、methods 中的函数、watch 中的函数、computed 中的函数 -------- 它们的 this 均是</p>
<p>​		（2）.new Vue（options）配置中：</p>
<p Vue实例对象="">​				data 函数、methods 中的函数、watch 中的函数、computed 中的函数 -------- 它们的 this 均是</p>
<h5 id="5vuecomponent的实例对象以后简称vc也可称之为组件实例对象"><a class="markdownIt-Anchor" href="#5vuecomponent的实例对象以后简称vc也可称之为组件实例对象">#</a> 5.VueComponent 的实例对象，以后简称 vc（也可称之为：组件实例对象）。</h5>
<p>​		Vue 的实例对象，以后简称 vm。</p>
<p><img src="C:%5CUsers%5C17281%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220406110929069.png" alt="image-20220406110929069"></p>
<h5 id="6关于不同版本的vue"><a class="markdownIt-Anchor" href="#6关于不同版本的vue">#</a> 6. 关于不同版本的 Vue：</h5>
<p>​	1.vue.js 与 vue.runtime.xxx.js 的区别：</p>
<p>​		（1）.vue.js 是完整版的 Vue，包含：核心功能 + 模板解析器。</p>
<p>​		（2）.vue.runtime.xxx.js 是运行版的 Vue，只包含：核心功能；没有模板解析器。</p>
<p>​	2. 因为 vue.runtime.xxx.js 没有模板解析器，所有不能使用 template 配置项，需要使用 render 函数接受到的 createElement 函数去制定具体内容。</p>
<h5 id="7ref"><a class="markdownIt-Anchor" href="#7ref">#</a> 7.ref</h5>
<p>​	（1）被用来给元素或子组件注册引用信息（id 的替代者）</p>
<p>​	（2）应用在 html 标签上获取的是真是 DOM 元素，应用组件标签上是组件实例对象（vc）</p>
<p>​	（3）使用方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">打标识：&lt;h1 ref=<span class="string">&quot;xxx&quot;</span>&gt;.......&lt;<span class="regexp">/h1&gt; 或 &lt;School ref=&quot;xxx&quot;&gt;&lt;/</span><span class="title class_">School</span>&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">获取：<span class="variable language_">this</span>.<span class="property">$ref</span>.<span class="property">xxx</span></span><br></pre></td></tr></table></figure>
<h5 id="8props"><a class="markdownIt-Anchor" href="#8props">#</a> 8.props</h5>
<p>​	功能：让组件接受外部传过来的数据</p>
<p>​	（1）传递数据</p>
<p>​			<Demo name ="xxx"/></p>
<p>​	（2）接受数据</p>
<p>​			第一种方式（只接受）：</p>
<p>​			props:[“name”]</p>
<p>​			第二种方式（限制类型）：</p>
<p>​			props:{</p>
<p>​				name:String</p>
<p>​			}</p>
<p>​			第三种方式（限制类型、限制必要性、指定默认值）：</p>
<p>​			props:{</p>
<p>​					name:{</p>
<p>​							type:String,// 类型</p>
<p>​							required:true,// 必要性</p>
<p>​							default:“老王”// 默认值</p>
<p>​					}</p>
<p>​			}</p>
<p>​	备注：</p>
<p>​		props 是只读的，Vue 底层会监测你对 props 的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，name 请赋值 props 的内容到 data 中一份，然后去修改 data 中的数据。</p>
<h5 id="9minix混入"><a class="markdownIt-Anchor" href="#9minix混入">#</a> 9.minix（混入）</h5>
<p>​	功能：可以把多个组件公用的配置提取成一个混入对象</p>
<p>​	使用方式：</p>
<p>​			第一步定义混合，例如：</p>
<p>​				{</p>
<p>​						data（）{…}，</p>
<p css-module=".....">​						methods：</p>
<p>​						…</p>
<p>​				}</p>
<p>​			第二部使用混入，例如：</p>
<p>​				（1）全局混入：Vue.mixin (xxx)</p>
<p>​				（2）局部混入：mixins:[‘xxx’]</p>
<h4 id="17插件"><a class="markdownIt-Anchor" href="#17插件">#</a> 17. 插件</h4>
<p>​		功能：用于增强 Vue</p>
<p>​		本质：包含 install 方法的一个对象，install 的第一个参数是 VUe，第二个以后的参数是从插件使用者传递的数。</p>
<p>​		定义插件：</p>
<p>​</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	对象.install = function(Vue, options)&#123;</span><br><span class="line"></span><br><span class="line">​							//1.添加全局过滤器</span><br><span class="line"></span><br><span class="line">​							Vue.filter(...)</span><br><span class="line"></span><br><span class="line">​							</span><br><span class="line"></span><br><span class="line">​							//2.添加全局命令</span><br><span class="line"></span><br><span class="line">​							Vue.directive(...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​							//3.配置全局混入（合）</span><br><span class="line"></span><br><span class="line">​							Vue.mixin(...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​							//4.添加实例方法</span><br><span class="line"></span><br><span class="line">​							Vue.prototype.$myMethod = function () &#123;.......&#125;</span><br><span class="line"></span><br><span class="line">​							Vue.prototype.$myPrototype = xxx</span><br><span class="line"></span><br><span class="line">​				&#125;</span><br></pre></td></tr></table></figure>
<p>​			使用插件：Vue.use ()</p>
<p><img src="C:%5CUsers%5C17281%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220406171346252.png" alt="image-20220406171346252"></p>
<h4 id="18todolist"><a class="markdownIt-Anchor" href="#18todolist">#</a> 18.Todolist</h4>
<p><img src="C:%5CUsers%5C17281%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220407141853492.png" alt="image-20220407141853492"></p>
<h4 id="19webstorage"><a class="markdownIt-Anchor" href="#19webstorage">#</a> 19.webStorage</h4>
<p>​	1. 存储内容大小一般支持 5MB 左右（不同浏览器可能不同）</p>
<p>​	2. 浏览器通过 Window.sessionStorage 和 Window.localStorage 属性实现本地存储机制。</p>
<p>​	3. 相关 API：</p>
<p>​		（1）xxxStorage.setItem(‘key’,‘value’);</p>
<p>​				该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</p>
<p>​		（2）xxxStorage.getItem(‘person’);</p>
<p>​				该方法接受一个键名作为参数，返回键名对应的值。</p>
<p>​		（3）xxxStorage.removeItem(‘key’);</p>
<p>​				该方法接受一个键名作为参数，并把该键名从存储中删除。</p>
<p>​		（4）xxxStorage.clear()</p>
<p>​				该方法会清空存储中的所有数据。</p>
<p>​	4. 备注：</p>
<p>​	（1）SessionStorage 存储的内容会随着浏览器窗口关闭而消失。</p>
<p>​	（2）LocalStorage 存储的内容，需要手动清除才会消失。</p>
<p>​	（3）xxxStorage.getItem (xxx)，如果对应的 value 获取不到，namegetItem 的返回值是 null。</p>
<p>​	（4）JSON.parse (null) 的结果依然是 null</p>
<h4 id="20vue自定义事件"><a class="markdownIt-Anchor" href="#20vue自定义事件">#</a> 20.Vue 自定义事件</h4>
<p>​	1. 一种组件间通信的方式，使用于：子组件 ===&gt; 父组件</p>
<p>​	2. 使用场景：A 是父组件，B 是子组件，B 想给 A 传数据，name 就要在 A 中给 B 绑定自定义事件（事件的回调在 A 中）。</p>
<p>​	3. 绑定自定义事件：</p>
<p>​		（1）第一种方式，在父组件中：&lt;Demo @atguigu=‘test’ /&gt; 或 <Demo v-on:atguigu='test'/></p>
<p>​		（2）第二种方式，在父组件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Demo</span> ref=<span class="string">&#x27;demo&#x27;</span>/&gt;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">xxx</span>.$on(<span class="string">&#x27;atguigu&#x27;</span>,<span class="variable language_">this</span>.<span class="property">test</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		（3）若想让自定义事件只能触发一次，可以使用 once 修饰符，或 $once 方法。</p>
<p>​	4. 触发自定义事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;atguigu&#x27;</span>,数据)</span><br></pre></td></tr></table></figure>
<p>​	5. 解绑自定义事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$off(<span class="string">&#x27;atguigu&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>​	6. 组件上也可以绑定原生的 DOM 事件，需要使用 native 修饰符。</p>
<p>​	7. 注意：通过</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">xxx</span>.$on(<span class="string">&#x27;atguigu&#x27;</span>,回调)</span><br></pre></td></tr></table></figure>
<p>绑定自定义事件时，回到要么哦诶之在 methods 中，要么使用箭头函数，否则 this 指向会出问题！</p>
<h4 id="21vue中使用组件的三大步骤"><a class="markdownIt-Anchor" href="#21vue中使用组件的三大步骤">#</a> 21.Vue 中使用组件的三大步骤</h4>
<p>​	一、定义组件（创建组件）</p>
<p>​		1. 使用 Vue.extend (options) 创建，其中 options 和 new Vue (options) 时传入的那个 options 几乎一样，区别如下：</p>
<p>​			（1）.el 不要写，为什么？------ 最终所有的组件都要经过一个 vm 管理，由 vm 中的 el 决定服务哪个容器</p>
<p>​			（2）.data 必须写成函数，为什么？------- 避免组件被复用时，数据存在引用关系。</p>
<p>​		2. 备注：使用 template 可以配置组件结构</p>
<p>​	二、注册组件</p>
<p>​		1. 局部注册：靠 new Vue 的时候传入 components 选项</p>
<p>​		2. 全局注册：靠 Vue.component (‘组件名’, 组件)</p>
<p>​	三、使用组件（写组件标签）</p>
<p>​		<school></school></p>
<h4 id="22vue全局事件总线"><a class="markdownIt-Anchor" href="#22vue全局事件总线">#</a> 22.Vue 全局事件总线</h4>
<p>​	1. 一种组件间通信的方式，适用于任意组件通信。</p>
<p>​	2. 安装全局事件总线：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="title function_">beforeCreate</span>(<span class="params"></span>)&#123;</span><br><span class="line">    	<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span> <span class="comment">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class="line">	&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>​	3. 使用事件总线：</p>
<p>​		（1）接受数据：A 组件想接受数据，则在 A 组件中给 $bus 绑定自定义事件，事件的回调留在 A 组件自身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;xxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		（2）提供数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$bus</span>.$emit(<span class="string">&#x27;xxx&#x27;</span>,数据)</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>​	4. 最好在 beforeDestroy 钩子中，用 $off 去解绑当前组件所用到的事件。</p>
<h4 id="23vue消息订阅与发布"><a class="markdownIt-Anchor" href="#23vue消息订阅与发布">#</a> 23.Vue 消息订阅与发布</h4>
<p><img src="C:%5CUsers%5C17281%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220413112307235.png" alt="image-20220413112307235"></p>
<p>nextTick</p>
<p><img src="C:%5CUsers%5C17281%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220413134726337.png" alt="image-20220413134726337"></p>
<h4 id="24vue动画"><a class="markdownIt-Anchor" href="#24vue动画">#</a> 24.Vue 动画</h4>
<p>​	1. 作用：在插入、更新和移除 DOM 元素时，在合适的时候给元素添加样式类名。</p>
<p>​	2. 图示</p>
<p><img src="C:%5CUsers%5C17281%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220413154318663.png" alt="image-20220413154318663"></p>
<p>​	3. 写法：</p>
<p>​		1. 准备好样式：</p>
<p>​		（1）v-enter：进入的起点</p>
<p>​		（2）v-enter-active：进入过程中</p>
<p>​		（3）v-enter-to：进入的终点</p>
<p>​		元素离开时的样式：</p>
<p>​		（1）v-leave：离开的起点</p>
<p>​		（2）v-leave-active：离开过程中</p>
<p>​		（3）v-leave-to：离开的终点</p>
<p>​	4. 使用<transition>包裹要过度的元素，并配置 name 属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;transition name= <span class="string">&#x27;hello&#x27;</span>&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>你好啊！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>
<p>​	5. 备注：若有多个元素需要过度，则需要使用：<transition-group>，且每个元素都要指定 key 值。</p>
<h4 id="25vue脚手架配置代理"><a class="markdownIt-Anchor" href="#25vue脚手架配置代理">#</a> 25.vue 脚手架配置代理</h4>
<p>方法一</p>
<p>​	在 vue.config.js 中添加如下配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">DevServer</span>：&#123;</span><br><span class="line">	<span class="attr">proxy</span>:<span class="string">&#x27;http://localhost:5000&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>​	1. 优点：配置简单，请求资源时直接发给前端（8080）即可</p>
<p>​	2. 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</p>
<p>​	3. 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，name 该请求会转发给服务器（优先匹配前端资源）</p>
<p>方法二</p>
<p>​	编写 vue.config.js 配置具体代理规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">transpileDependencies</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">devServer</span>:&#123;</span><br><span class="line">    <span class="attr">proxy</span>:&#123;</span><br><span class="line">      <span class="string">&#x27;/api1&#x27;</span>:&#123;<span class="comment">//匹配所有以&#x27;/api1&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>:<span class="string">&#x27;http://localhost:5000&#x27;</span>,<span class="comment">//代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>:&#123;<span class="string">&#x27;^/api1&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/api2&#x27;</span>:&#123;<span class="comment">//匹配所有以&#x27;/api2&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>:<span class="string">&#x27;http://localhost:5001&#x27;</span>,<span class="comment">//代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>:&#123;<span class="string">&#x27;^/api2&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  changeOrigin设置为true时，服务器收到的请求头中的host为：localhost：5000</span></span><br><span class="line"><span class="comment">  changeOrigin设置false时，服务器收到的请求头中的host为：localhost：8080</span></span><br><span class="line"><span class="comment">  changeOrigin默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>​	1. 优点：可以配置多个代理，切可以灵活的控制请求是否走代理。</p>
<p>​	2. 缺点：配置略微繁琐，请求资源时必须加前缀。</p>
<h4 id="26vue插槽"><a class="markdownIt-Anchor" href="#26vue插槽">#</a> 26.Vue 插槽</h4>
<p>1. 作用：让父组件可以向子组件制定位置插入 html 结构，也是一种组件之间通信的方式，适用于 <strong>父组件 ===&gt; 子组件</strong></p>
<p>2. 分类：默认插槽、具名插槽、作用域插槽</p>
<p>3. 使用方式</p>
<p>​	1. 默认插槽</p>
<p>​			父组件中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Category</span> <span class="attr">title</span>=<span class="string">&#x27;美食&#x27;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​			子组件中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">&#x27;category&#x27;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">slot</span>&gt;</span>插槽默认内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​	2. 具名插槽</p>
<p>​			父组件中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Category</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&#x27;center&#x27;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">&#x27;category&#x27;</span>&gt;</span>html结构1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>：<span class="attr">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> &gt;</span>html结构2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​			子组件中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&#x27;center&#x27;</span>&gt;</span>插槽默认内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&#x27;footer&#x27;</span>&gt;</span>插槽默认内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​	3. 作用域插槽</p>
<p>​		（1）理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（games 数据在 category 组件中，但是使用数据所遍历出来的结构由 App 组件决定）子组件想父组件传值</p>
<p>​		（2）具体编码</p>
<p>​			父组件中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Category</span> <span class="attr">title</span>=<span class="string">&quot;游戏&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">scope</span>=<span class="string">&quot;game&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(games, index) in game.games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>&#123;&#123; games &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Category</span> <span class="attr">title</span>=<span class="string">&quot;游戏&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">scope</span>=<span class="string">&quot;game&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;(games, index) in game.games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>&#123;&#123; games &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">Category</span> <span class="attr">title</span>=<span class="string">&quot;游戏&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;game&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">h4</span> <span class="attr">v-for</span>=<span class="string">&quot;(games, index) in game.games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>&#123;&#123; games &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​			子组件中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;category&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:games</span> = <span class="string">&quot;games&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">name</span>: <span class="string">&quot;Category&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">props</span>: [<span class="string">&quot;title&quot;</span>],</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">games</span>: [<span class="string">&quot;红警&quot;</span>, <span class="string">&quot;CF&quot;</span>, <span class="string">&quot;DNF&quot;</span>, <span class="string">&quot;LOL&quot;</span>],</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="27vuex"><a class="markdownIt-Anchor" href="#27vuex">#</a> 27.Vuex</h4>
<p>​    	1.Vue 是什么</p>
<p>​		概念：专门在 VUe 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应用中多个组件的共享状态集中式管理（读、写），也是一种组件间通信的方式，且适合用于任意组件间通信。</p>
<p>​		2. 什么时候使用 Vuex</p>
<p>​		（1）多个组件依赖于同一状态</p>
<p>​		（2）来自不同组件的行为需要变更同一状态</p>
<p><img src="C:%5CUsers%5C17281%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220422100630576.png" alt="image-20220422100630576"></p>
<p><img src="C:%5CUsers%5C17281%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220422100645238.png" alt="image-20220422100645238"></p>
<p><img src="C:%5CUsers%5C17281%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220422100913560.png" alt="image-20220422100913560"></p>
<p>1. 概念</p>
<p>​	    在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应用中多个组件的共享状态进行集中式的管理（读 / 写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<p>2. 何时使用</p>
<p>​		多个组件需要共享数据时</p>
<p>3. 搭建 vuex 环境</p>
<p>​	（1）创建文件: src/store/index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//应用Vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions对象--响应组件中用户的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;</span><br><span class="line"><span class="comment">//准备mutations对象--修改state中的数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;</span><br><span class="line"><span class="comment">//准备state对象--保存具体的数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title function_">store</span>(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>​	（2）在 main.js 中创建 vm 时传入 store 配置项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入vue</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入App组件，它是所有组件的父组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="comment">//引入插件 </span></span><br><span class="line"><span class="keyword">import</span> vueResource <span class="keyword">from</span> <span class="string">&#x27;vue-resource&#x27;</span></span><br><span class="line"><span class="comment">// 引入vuex</span></span><br><span class="line"><span class="comment">// import Vuex from &#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">// 引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="comment">//关闭vue的生产提示</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"><span class="comment">// 使用插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(vueResource)</span><br><span class="line"><span class="comment">// Vue.use(Vuex)</span></span><br><span class="line"><span class="comment">//创建Vue实例对象------vm</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">  store,</span><br><span class="line">  <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span><span class="comment">//安装全局事件总线</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4. 基本使用</p>
<p>​	（1）初始化数据、配置 actions、配置 mutations，操作文件 store.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该文件用于创建vuex中最为核心的store</span></span><br><span class="line"><span class="comment">// 用于相应组件中的动作</span></span><br><span class="line"><span class="keyword">import</span> &#123; P &#125; <span class="keyword">from</span> <span class="string">&#x27;core-js/modules/_export&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="comment">// jia(context,value)&#123;</span></span><br><span class="line">    <span class="comment">//     context.commit(&#x27;JIA&#x27;,value)</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="comment">// jian(context,value)&#123;</span></span><br><span class="line">    <span class="comment">//     context.commit(&#x27;JIAN&#x27;,value)</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="title function_">jiaOdd</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(context.<span class="property">state</span>.<span class="property">sum</span> % <span class="number">2</span>)&#123;</span><br><span class="line">            context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">jianWait</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">        &#125;,<span class="number">500</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于操作数据（state）</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="title function_">JIA</span>(<span class="params">state,value</span>)&#123;</span><br><span class="line">        state.<span class="property">sum</span> += value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">JIAN</span>(<span class="params">state,value</span>)&#123;</span><br><span class="line">        state.<span class="property">sum</span> -= value</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于存储数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">    <span class="attr">sum</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">school</span>:<span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">    <span class="attr">subject</span>:<span class="string">&#x27;前端&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于将state中的数据进行加工</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">    <span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="property">sum</span>*<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state,</span><br><span class="line">    getters,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>​	（2）组件中读取 vuex 中的数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$store.<span class="property">state</span>.<span class="property">sum</span></span><br></pre></td></tr></table></figure>
<p>​	（3）组件中修改 vuex 中的数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$stote.<span class="title function_">dispatch</span>(<span class="string">&#x27;action中的方法名&#x27;</span>,数据)或$store.<span class="title function_">commit</span>(<span class="string">&#x27;mutations中的方法名&#x27;</span>,数据)</span><br></pre></td></tr></table></figure>
<p>​	备注：若没有网络请求或其他业务逻辑，组件中也可以越过 ac tions，即不写 dispatch，直接写 commit</p>
<h5 id="store组件"><a class="markdownIt-Anchor" href="#store组件">#</a> store 组件：</h5>
<p>getters：</p>
<p>​		1. 使用：当 state 中的数据需要进过加工后再使用时，可以使用 getters 加工</p>
<p>​		2. 再 store.js 中追加 getters 配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/s/ 用于将state中的数据进行加工</span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  <span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> state.<span class="property">sum</span>*<span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actions,</span><br><span class="line">  mutations,</span><br><span class="line">  state,</span><br><span class="line">  getters,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>​		3. 组件中读取数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$store.<span class="property">getters</span>.<span class="property">bigSum</span>	</span><br></pre></td></tr></table></figure>
<h5 id="四个map方法的使用"><a class="markdownIt-Anchor" href="#四个map方法的使用">#</a> 四个 map 方法的使用</h5>
<p>​	1.mapState 方法：用于帮助我们映射 state 中的数据为计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借助mapState生成计算属性，从state中读取数据，（对象写法）</span></span><br><span class="line">    ...<span class="title function_">mapState</span>(&#123;<span class="attr">sum</span>:<span class="string">&#x27;sum&#x27;</span>,<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>,&#125;),</span><br><span class="line">  <span class="comment">//借助mapState生成计算属性，从state中读取数据，（数组写法）              </span></span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;bigSum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>]),</span><br></pre></td></tr></table></figure>
<p>​	2.mapGetters 方法：用于帮助我们映射 getters 中的数据为计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借助mapGetters生成计算属性，从state中读取数据，（对象写法）</span></span><br><span class="line"> ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;bigSum&#x27;</span>]),</span><br><span class="line"> <span class="comment">//借助mapGetters生成计算属性，从state中读取数据，（数组写法）</span></span><br><span class="line"> ...<span class="title function_">mapGetters</span>(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>​	3.mapActions 方法：用于帮助我们生成 actions 对话的方法， 包含 store.dispatch (xxx) 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">     <span class="comment">// 借助mapActions生成对应的方法，方法中会调用commit去联系Actions（对象写法）</span></span><br><span class="line"> ...<span class="title function_">mapActions</span>([<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>​	4.mapMutations 方法，用于帮助我们生成于 mutations 对话的方法，包含 store.commit (xxx) 的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 借助mapMutations生成对应的方法，方法中会调用commit去联系mutations（对象写法）</span></span><br><span class="line">  ...<span class="title function_">mapMutations</span>(&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class="line">    <span class="comment">// 借助mapMutations生成对应的方法，方法中会调用commit去联系mutations（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>]),</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h5 id="模块化命名空间"><a class="markdownIt-Anchor" href="#模块化命名空间">#</a> 模块化 + 命名空间</h5>
<p>​	1. 目的：让代码更好的维护，让多种数据分类更加明确。</p>
<p>​	2. 修改 store.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> personOptions =  &#123;</span><br><span class="line">    <span class="attr">namespaced</span>: <span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">    <span class="attr">actions</span>: &#123;</span><br><span class="line">        <span class="title function_">addPersonWang</span>(<span class="params">context, value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value.<span class="property">name</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;王&#x27;</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">                context.<span class="title function_">commit</span>(<span class="string">&#x27;ADD_PERSON&#x27;</span>, value)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">&#x27;添加的必须姓王&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">addPersonServer</span>(<span class="params">context</span>) &#123;</span><br><span class="line">            axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api.uixsj.cn/hitokoto/get?type=social&#x27;</span>).<span class="title function_">then</span>(</span><br><span class="line">                <span class="function"><span class="params">Response</span> =&gt;</span> &#123;</span><br><span class="line">                    context.<span class="title function_">commit</span>(<span class="string">&#x27;ADD_PERSON&#x27;</span>, &#123; <span class="attr">id</span>: <span class="title function_">nanoid</span>(), <span class="attr">name</span>: <span class="title class_">Response</span>.<span class="property">data</span> &#125;)</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="params">Error</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">alert</span>(<span class="title class_">Error</span>.<span class="property">message</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mutations</span>: &#123;</span><br><span class="line">        <span class="title function_">ADD_PERSON</span>(<span class="params">state, value</span>) &#123;</span><br><span class="line">            state.<span class="property">personList</span>.<span class="title function_">unshift</span>(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">personList</span>: [</span><br><span class="line">            &#123; <span class="attr">id</span>: <span class="string">&#x27;001&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getters</span>: &#123;</span><br><span class="line">        <span class="title function_">firstPersonName</span>(<span class="params">state</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.<span class="property">personList</span>[<span class="number">0</span>].<span class="property">name</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">modules</span>:&#123;</span><br><span class="line">        countOptions,</span><br><span class="line">        personOptions,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>3. 开启命名空间后，组件中读取 state 数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">personOptions</span>.<span class="property">personList</span>;</span><br><span class="line"><span class="comment">//方式二：借助mapGetters读取</span></span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">&#x27;personOptions&#x27;</span>,[<span class="string">&#x27;personList&#x27;</span>]),</span><br></pre></td></tr></table></figure>
<p>4. 开启命名空间后，组件中读取 getters 数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&quot;personOptions/firstPersonName&quot;</span>];</span><br><span class="line"><span class="comment">//方式二：借助mapGetters读取</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(<span class="string">&#x27;countOptions&#x27;</span>, [<span class="string">&#x27;bigSum&#x27;</span>]),</span><br></pre></td></tr></table></figure>
<p>5. 开启命名空间后，组件中调用 dispatch</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&quot;personOptions/addPersonWang&quot;</span>, personObj);</span><br><span class="line"><span class="comment">//方式二：mapActions</span></span><br><span class="line">...<span class="title function_">mapActions</span>(<span class="string">&#x27;countOptions&#x27;</span>,&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure>
<p>6. 开启命名空间后，组件中调用 commit</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接commit</span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&quot;personOptions/ADD_PERSON&quot;</span>, personObj);</span><br><span class="line"><span class="comment">//方式二：借助mapMutations</span></span><br><span class="line">...<span class="title function_">mapMutations</span>(<span class="string">&#x27;countOptions&#x27;</span>,&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure>
<h4 id="28路由"><a class="markdownIt-Anchor" href="#28路由">#</a> 28. 路由</h4>
<h5 id="1对vue-router的理解"><a class="markdownIt-Anchor" href="#1对vue-router的理解">#</a> 1. 对 vue-router 的理解</h5>
<p>vue 的一个插件库，专门用来实现 SPA 应用</p>
<h5 id="2对spa的理解"><a class="markdownIt-Anchor" href="#2对spa的理解">#</a> 2. 对 SPA 的理解</h5>
<p>（1）单页 web 应用（single page web application ，SPA）</p>
<p>（2）整个应用只有<strong>一个完整的页面</strong>（index.html）</p>
<p>（3）点击页面中的导航链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部刷新。</strong></p>
<p>（4）数据需要通过 ajax 请求获取</p>
<h5 id="3路由的理解"><a class="markdownIt-Anchor" href="#3路由的理解">#</a> 3. 路由的理解</h5>
<h6 id="1什么是路由"><a class="markdownIt-Anchor" href="#1什么是路由">#</a> （1）什么是路由</h6>
<p>​		1. 一个路由就是一组映射关系（key-value）</p>
<p>​		2.<strong>key</strong> 为路径，<strong>value</strong> 可能是 function 或 component</p>
<h6 id="2路由分类"><a class="markdownIt-Anchor" href="#2路由分类">#</a> （2）路由分类</h6>
<p>​		1. 后端路由：</p>
<p>​			1）理解：<strong>value</strong> 是<strong> function</strong>，用于处理客户端提交的请求</p>
<p>​			2）工作过程：服务器接受到的一个请求时，根据<strong>请求路径</strong>找到匹配的<strong>函数</strong>来处理请求，返回<strong>相应数据</strong>。</p>
<p>​		2. 前端路由：</p>
<p>​			1）理解：value 是 component，用于展示页面内容。</p>
<p>​			2）工作过程：当浏览器的路径改变时，对应的组件就会显示。</p>
<h5 id="4基本使用"><a class="markdownIt-Anchor" href="#4基本使用">#</a> 4. 基本使用</h5>
<p>​	1. 安装 vue-router, 命令: npm i vue-router</p>
<p>​	2. 引用插件：Vue.use（VueRouter）</p>
<p>​	3. 编写 router 配置项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 专门用于创建整个应用的路由器</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="comment">// 引入组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个路由器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>4. 实现切换（active-class 可配置高亮样式）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- vue中借助router-link标签实现路由的切换 --&gt;</span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">class</span>=<span class="string">&quot;list-group-item &quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span> <span class="attr">to</span>=<span class="string">&quot;about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>5. 指定展示位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 指定组件的呈现位置 --&gt;</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h5 id="5几个注意点"><a class="markdownIt-Anchor" href="#5几个注意点">#</a> 5. 几个注意点</h5>
<p>​	1. 路由组件通过存放在 pages 文件夹，一般组件通常存放在 components 文件夹。</p>
<p>​	2. 通过切换，‘隐藏了’的路由组件，默认是被销毁掉的，需要的时候再去挂载。</p>
<p>​	3. 每个组件都有自己的 $route 属性，里面存储着自己的路由信息。</p>
<p>​	4. 整个应用只有一个 router，可以通过组件的 $router 属性获取到。</p>
<h5 id="6嵌套路由多级"><a class="markdownIt-Anchor" href="#6嵌套路由多级">#</a> 6. 嵌套路由（多级）</h5>
<p>​	1. 配置路由规则，使用 children 配置项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">        &#125;,</span><br><span class="line">     </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">            <span class="attr">children</span>:[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">                    <span class="attr">component</span>:<span class="title class_">News</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">                    <span class="attr">component</span>:<span class="title class_">Message</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<p>​	2. 跳转（要写完整路径）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span><span class="attr">to</span>=<span class="string">&quot;/home/news&quot;</span>&gt;</span>News<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="7路由传参"><a class="markdownIt-Anchor" href="#7路由传参">#</a> 7. 路由传参</h5>
<h6 id="1query传参"><a class="markdownIt-Anchor" href="#1query传参">#</a> （1）query 传参</h6>
<p>​	1. 传递参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 跳转路由，并携带query参数，to的字符串写法 --&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;`/home/message/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;</span>&gt;</span>&#123;&#123;</span></span><br><span class="line"><span class="language-xml">          m.title</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;&lt;/router-link</span></span><br><span class="line"><span class="language-xml">        &gt;<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- 跳转路由，并携带query参数，to的数组写法 --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">router-link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            path: &#x27;/home/message/detail&#x27;,</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            query: &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">              id: m.id,</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">              title: m.title,</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">            &#125;,</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">          &#125;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &gt;</span>&#123;&#123; m.title &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>​	2. 接受参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>消息编号：&#123;&#123;$route.query.id&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>消息标题：&#123;&#123;$route.query.title&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="2params参数"><a class="markdownIt-Anchor" href="#2params参数">#</a> （2）params 参数</h6>
<pre><code>1.配置路由，声明接受params参数
</code></pre>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="attr">name</span>:<span class="string">&#x27;guanyu&#x27;</span>,</span><br><span class="line">           <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">           <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">           <span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">           <span class="attr">children</span>:[</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">                   <span class="attr">component</span>:<span class="title class_">News</span>,</span><br><span class="line">               &#125;,</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">                   <span class="attr">component</span>:<span class="title class_">Message</span>,</span><br><span class="line">                   <span class="attr">children</span>:[</span><br><span class="line">                       &#123;</span><br><span class="line">                           <span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">                           <span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title&#x27;</span>,<span class="comment">//占位符</span></span><br><span class="line">                           <span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line">                       &#125;</span><br><span class="line">                   ]</span><br><span class="line">               &#125;</span><br><span class="line">           ]</span><br><span class="line">       &#125;,</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure>
<p>​	2. 传递参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;</span>&gt;&#123;&#123;</span><br><span class="line">        m.<span class="property">title</span></span><br><span class="line">      &#125;&#125;&lt;/router-link</span><br><span class="line">      &gt;&amp;nbsp;&amp;nbsp;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-link</span><br><span class="line">         :to=<span class="string">&quot;&#123;</span></span><br><span class="line"><span class="string">           name: &#x27;xiangqing&#x27;,</span></span><br><span class="line"><span class="string">           params: &#123;</span></span><br><span class="line"><span class="string">             id: m.id,</span></span><br><span class="line"><span class="string">             title: m.title,</span></span><br><span class="line"><span class="string">           &#125;,</span></span><br><span class="line"><span class="string">         &#125;&quot;</span></span><br><span class="line">         &gt;&#123;&#123; m.<span class="property">title</span> &#125;&#125;</span><br><span class="line">       &lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
<p>特别注意：路由携带 params 参数时。若使用 to 的对象写法，则不能使用 path 配置项，必须使用 name 配置</p>
<p>​	3. 接收参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;li&gt;消息编号：&#123;&#123;$route.<span class="property">params</span>.<span class="property">id</span>&#125;&#125;&lt;/li&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>消息标题：&#123;&#123;$route.params.title&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h5 id="8命名路由"><a class="markdownIt-Anchor" href="#8命名路由">#</a> 8. 命名路由</h5>
<p>​	1. 作用：可以简化路由的跳转</p>
<p>​	2. 如何使用：</p>
<p>​	（1）. 给路由命名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="attr">name</span>:<span class="string">&#x27;guanyu&#x27;</span>,</span><br><span class="line">           <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">           <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">           <span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">           <span class="attr">children</span>:[</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">                   <span class="attr">component</span>:<span class="title class_">News</span>,</span><br><span class="line">               &#125;,</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">                   <span class="attr">component</span>:<span class="title class_">Message</span>,</span><br><span class="line">                   <span class="attr">children</span>:[</span><br><span class="line">                       &#123;</span><br><span class="line">                           <span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">                           <span class="attr">path</span>:<span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">                           <span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line">                       &#125;</span><br><span class="line">                   ]</span><br><span class="line">               &#125;</span><br><span class="line">           ]</span><br><span class="line">       &#125;,</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure>
<p>​	（2）. 简化跳转</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-link</span><br><span class="line">          :to=<span class="string">&quot;&#123;</span></span><br><span class="line"><span class="string">              name:&#x27;xiangqing&#x27;,</span></span><br><span class="line"><span class="string">          //  path: &#x27;/home/message/detail&#x27;,</span></span><br><span class="line"><span class="string">            query: &#123;</span></span><br><span class="line"><span class="string">              id: m.id,</span></span><br><span class="line"><span class="string">              title: m.title,</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">          &#125;&quot;</span></span><br><span class="line">          &gt;&#123;&#123; m.<span class="property">title</span> &#125;&#125;</span><br><span class="line">&lt;/router-link&gt;</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<h5 id="9路由props配置"><a class="markdownIt-Anchor" href="#9路由props配置">#</a> 9. 路由 props 配置</h5>
<p>​	作用：让路由组件更方便的收到参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">    <span class="comment">// params形式</span></span><br><span class="line">    <span class="comment">// path:&#x27;detail/:id/:title&#x27;,</span></span><br><span class="line">    <span class="comment">// query形式</span></span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line">                           </span><br><span class="line">     <span class="comment">// props的第一种写法，值为对象，该对象中的所有key-value都会以props的形式传给Detail组件</span></span><br><span class="line">     <span class="attr">props</span>:&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="string">&#x27;hello&#x27;</span>&#125;,</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传给Detail</span></span><br><span class="line">     <span class="attr">props</span>:<span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">     <span class="comment">// props的第三种写法,值为函数</span></span><br><span class="line">     <span class="title function_">props</span>(<span class="params">$route</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">id</span>:$route.<span class="property">query</span>.<span class="property">id</span>,<span class="attr">title</span>:$route.<span class="property">query</span>.<span class="property">title</span>&#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="comment">// props(&#123;query&#125;)&#123;</span></span><br><span class="line">         <span class="comment">//return &#123;id:query.id,title:query.title&#125;</span></span><br><span class="line">     <span class="comment">// &#125;,</span></span><br><span class="line">     <span class="comment">// props(&#123;query:&#123;id,title&#125;&#125;)&#123;</span></span><br><span class="line">     		<span class="comment">//return &#123;id,title&#125;</span></span><br><span class="line">     <span class="comment">// &#125;,</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="10-router-link的replace属性"><a class="markdownIt-Anchor" href="#10-router-link的replace属性">#</a> 10. <router-link>的 replace 属性</h5>
<p>​	1. 作用：控制路由跳转是操作浏览器历史记录的模式</p>
<p>​	2. 浏览器的历史记录有两种写入方式：分贝为 push 和 replace，push 是追加历史记录，replace 是替换当前记录。路由跳转时候默认为 push。</p>
<p>​	3. 如何开启 replace 模式： <router-link replace>News</router-link></p>
<h5 id="11编程式路由导航"><a class="markdownIt-Anchor" href="#11编程式路由导航">#</a> 11. 编程式路由导航</h5>
<p>​	1. 作用：不借助<router-link>实现路由跳转，让路由跳转更加灵活</p>
<p>​	2. 具体编码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $router的两个API</span></span><br><span class="line">    <span class="title function_">pushShow</span>(<span class="params">m</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="comment">// query: &#123;</span></span><br><span class="line">        <span class="comment">//   id: m.id,</span></span><br><span class="line">        <span class="comment">//   title: m.title,</span></span><br><span class="line">        <span class="comment">// &#125;,</span></span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">        <span class="attr">params</span>:&#123;</span><br><span class="line">          <span class="attr">id</span>: m.<span class="property">id</span>,</span><br><span class="line">          <span class="attr">title</span>: m.<span class="property">title</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">replaceShow</span>(<span class="params">m</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123;</span><br><span class="line">        <span class="attr">query</span>: &#123;</span><br><span class="line">          <span class="attr">id</span>: m.<span class="property">id</span>,</span><br><span class="line">          <span class="attr">title</span>: m.<span class="property">title</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>()<span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>()<span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(<span class="number">3</span>)<span class="comment">//可以前进也可以后退</span></span><br></pre></td></tr></table></figure>
<h5 id="12缓存路由组件"><a class="markdownIt-Anchor" href="#12缓存路由组件">#</a> 12. 缓存路由组件</h5>
<p>​	1. 作用：让不展示的路由组件保持挂载，不被销毁</p>
<p>​	2. 具体编码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive include=<span class="string">&quot;News&quot;</span>&gt;</span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">    &lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<h5 id="13两个新的生命周期钩子"><a class="markdownIt-Anchor" href="#13两个新的生命周期钩子">#</a> 13. 两个新的生命周期钩子</h5>
<p>​	1. 作用：路由组件所有独有的两个钩子，用于捕获路由组件的激活状态。</p>
<p>​	2. 具体名字：</p>
<p>​		（1）activated 路由组件被激活时触发。</p>
<p>​		（2）deactivated 路由组件失活时触发。</p>
<h5 id="14路由守卫"><a class="markdownIt-Anchor" href="#14路由守卫">#</a> 14. 路由守卫</h5>
<p>​	1. 作用：对路由进行权限控制</p>
<p>​	2. 分类：全局守卫、独享守卫、组件内守卫</p>
<p>​	3. 全局守卫</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局前置路由守卫---初始化的时候被调用，每次路由切换之前被调用</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if(to.path === &#x27;/home/news&#x27; || &#x27;/home/message&#x27;)&#123;</span></span><br><span class="line">        <span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span> == <span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line">            <span class="title function_">next</span>()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;到底喜欢什么,无权限查看&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局后置路由守卫---初始化的时候被调用，每次路由切换之前被调用  </span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = to.<span class="property">meta</span>.<span class="property">title</span> || <span class="string">&#x27;硅谷系统&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​	4. 独享路由守卫</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="comment">// ...</span></span><br><span class="line">  	<span class="keyword">if</span> (to.<span class="property">meta</span>.<span class="property">isAuth</span> == <span class="literal">true</span>) &#123;</span><br><span class="line">     	  <span class="keyword">if</span> (<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>) &#123;</span><br><span class="line">    	      <span class="title function_">next</span>()</span><br><span class="line">    	  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	     <span class="title function_">alert</span>(<span class="string">&#x27;到底喜欢什么,无权限查看&#x27;</span>)</span><br><span class="line">   	   &#125;</span><br><span class="line"> 	 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  	  	 <span class="title function_">next</span>()</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	5. 组件内守卫</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过路由规则，进入该组件时被调用</span></span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 通过路由规则，离开该组件时被调用</span></span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="15路由器的两种工作模式"><a class="markdownIt-Anchor" href="#15路由器的两种工作模式">#</a> 15. 路由器的两种工作模式</h5>
<p>​	1. 对于一个 url 来说，什么事 hash 值？ #及其后面的内容就是 hash 值。</p>
<p>​	2.hash 值不会包含在 http 请求中，即：hash 值不会带给服务器。</p>
<p>​	3.hash 模式：</p>
<p>​	（1）地址中永远待着 #号。不美观。</p>
<p>​	（2）若以后将地址通过第三方手机 app 分享，若 app 校验严格，则地址会标记为不合法。</p>
<p>​	（3）兼容性较好。</p>
<p>​	4.history 模式：</p>
<p>​	（1）地址干净，美观。</p>
<p>​	（2）兼容性和 hash 模式相比略差。</p>
<p>​	（3）应用部署上线时需要后端人员支持，解决刷新服务器端 404 的问题。（桌面 demo 文件）</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue面试题</title>
    <url>/2022/07/07/vue%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>echars 使用步骤</p>
<p>1. 创建一个存放图表的容器，往往使用一个 div 作为容器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 100%&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2. 图表初始化，Echarts 绘图时调用 echarts.init () API 实现图表初始化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;container&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> myChart = echarts.<span class="title function_">init</span>(dom);</span><br></pre></td></tr></table></figure>
<p>3. 设置图表配置项，传入数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">    <span class="attr">xAxis</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tue&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thu&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">yAxis</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">series</span>: [&#123;</span><br><span class="line">        <span class="attr">data</span>: [<span class="number">820</span>, <span class="number">932</span>, <span class="number">901</span>, <span class="number">934</span>, <span class="number">1290</span>, <span class="number">1330</span>, <span class="number">1320</span>],<span class="comment">//在这里修改数据</span></span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;line&#x27;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4. 绘制图表。调用 setOption () API 实现图表绘制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (option &amp;&amp; <span class="keyword">typeof</span> option === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    myChart.<span class="title function_">setOption</span>(option, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>html 块级元素  div 、p、h1-h5、br----------------------<br>
 行内元素 a、span、strong、b、img、input、select、</p>
<h4 id="1flex布局"><a class="markdownIt-Anchor" href="#1flex布局">#</a> 1.flex 布局</h4>
<p>flex 是弹性布局，我们设置为 flex 的元素成为容器，容器内的其他子元素成为项目，容器默认是有两根轴，一个是水平的主轴 main aixs，一个是垂直的交叉轴 cross axis</p>
<p>容器的属性有 flex-direction：设置项目的排列方向 row row-reserve column column-reverse</p>
<p>flex-wrap：当子元素超过父容器的长度时，是否换行，wrap nowrap wrap-reverse</p>
<p>flex-flow 是 flex-direction 和 flex-wrap 的简写</p>
<p>justify-content：设置项目主轴上对齐方式，flex-start ，flex-end，center，space-between 两端对齐，space-around 中间是边的二倍，space-evenly 间距相等</p>
<p>align-items：设置项目交叉轴的对齐方式，默认是 stretch，flex-start，flex-end，center，baseline</p>
<p>align-content：当交叉轴有多余空间时，调整内容的对齐方式。</p>
<p>项目属性有 order：设置显示顺序，序号越小。排在越前</p>
<p>flex-grow 项目的放大比例，默认 0 ，</p>
<p>flex-shrink 项目的缩小比例，默认 1</p>
<p>flex-basis 项目的默认宽度</p>
<p>flex 是 flex-grow 和 flex-shrink 和 flex-basis 的简写默认 0 1 auto</p>
<p>align-self 可以单独设置项目的对齐方式，可覆盖 align-items</p>
<h4 id="2promise"><a class="markdownIt-Anchor" href="#2promise">#</a> 2.promise</h4>
<p>promise 是 es6 新增的语法，它是解决异步编程的一种方案，他支持链式调用，可以解决回调地狱问题，promise 有三种状态，padding 进行中，fulfilled 已成功。rejected 已失败。promise 对象他是一个构造函数，他的参数有两个，第一个 resolve 可以把 padding 状态改变为 fulfilled，第二个 reject 他可以把 padding 改成 rejected 状态。promise 对象的实例有三个方法，第一个是 then ()，他是当 promise 的状态改变的时候就会执行这个回调，第二个是 catch () 他是用来捕获错误的回调函数，第三个是 finally 他不管 promise 最后的状态如何，都会执行。promise 还有 all 和 race 方法，他们都是多个 promise 对象组成的一个新的 promise 实例，all 是当所有的请求都成功的时候才会返回成功，race 只要有一个请求成功就会返回成功。</p>
<h4 id="3组件间的传值"><a class="markdownIt-Anchor" href="#3组件间的传值">#</a> 3. 组件间的传值</h4>
<p>我们常用的父子组件之间传值是 props，子组件也可以向父组件传值，子组件用 emit 发送，父组件用 on 接受，还有常用的就是 vuex 和全局事件总线在任意组件之间都可以传值，还有就是插槽也可以进行传值，默认和具名插槽可以实现父组件向子组件传值，作用域插槽可以实现子组件向父组件传值。最后 ref 也可以通过属性传值，父组件可以改变子组件中的数据。</p>
<h4 id="4axios"><a class="markdownIt-Anchor" href="#4axios">#</a> 4.axios</h4>
<p>axios 的原理就是 ajax，是对 ajax 的封装，他是基于 promise 实现的，符合 es6 语法，我们在项目中可以配置一个全局的 axios，在 main.js 中引入 axios 的包，然后配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios.defaults.baseURL</span><br></pre></td></tr></table></figure>
<p>之后在 vue 的原型上给他添加一个属性，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue.prototype.$http = axios</span><br></pre></td></tr></table></figure>
<p>然后我们在组件中就可以使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$http.请求方式</span><br></pre></td></tr></table></figure>
<p>然后还可以配置请求拦截器 request。我们通常的用的请求方式就是 get 和 post，我们也可以把 axios 封装成自己的 api，方便我们以后的调用和修改。比如说就是用户没有登录的时候添加商品，当它点击他添加，先是请求拦截器就是在请求发送之前，在其请求头里给添加一个 token，然后得到服务器相应之后，响应拦截器判断这个 token 是否有值，如果没有，那路由跳转到登录页面。</p>
<p>原生 ajax，先 new 一个 XMLHttpRequest，然后 open 打开请求地址和方式，然后 onreadystatechange =function（），最后发送 send</p>
<h4 id="5vuex"><a class="markdownIt-Anchor" href="#5vuex">#</a> 5.vuex</h4>
<p>vuex 是对 vue 中数据集中管理的一个插件，他一共有 5 个属性，分别是 state，用来存放数据源信息，就是一些公用的数据都要放在 state 中存放，在组件中使用 store.state. 数据名，也可以用 mapState 获取，然后就是 mutations，他是唯一一个可以改变 store 状态的一个方法，在组件中使用 store.commit 来触发事件，也可以用简写方式 mapMutations 触发，还有就是 action 他的功能和 mutations 差不多，但是 actions 可以进行异步的操作，在组件中使用 store.dispatch 来触发事件，或者用简写方式 mapActions，还有 getters 属性，他就和计算属性 computed 差不多，就是把 state 中的数据加工一下，return 出来，我我们直接使用加工过之后的数据，可以用 store.getters. 方法名字或者 mapGetters 来触发，最后一个就是模块化 module，就是可以把 store 分成若干个模块，每个模块都有 state、mutations、actions、getters 属性，他是为了方便我们更好的管理代码。</p>
<h4 id="6生命周期"><a class="markdownIt-Anchor" href="#6生命周期">#</a> 6. 生命周期</h4>
<p>vue 的生命周期可以分为 8 个阶段，第一个就是 beforeCreate，组件实例被创建之前，这个时候是没有数据的，然后就是 created，组件实例被创建，这是时候已经有了数据了，我们可以在这里去异步请求接口获取数据，然后就是 beforeMount，这个是组件实例被挂载之前，虚拟的 dom 已经创建，但是真实的 dom 没有被创建，再接着就是 mounted，这个时候组件实例被挂载，真实 dom 创建，页面也渲染出来了，我的项目中我是在 mounted 去异步请求获取数据，在这里还可以执行自定义事件，启动定时器等，然后就是 beforeUpdate，这是被更新之前，然后就是 updated 这是时候数据已经被更新了，然后就是 beforeDestroy，这是组件实例被销毁之前，我们在这里可以清除定时器，什么的，最后就是 destroyed 这个时候组件实例被销毁了。还有两个就是路由里 keep-alive 的两个声明周期钩子，一个是 activeted，他是被 keep-alive 缓存的组件被激活的时候调用，另一个是 deactivated，缓存的组件被停用的时候调用，还有一个就是 errorCapture 用来捕获异常的。</p>
<h4 id="7computed和watch区别"><a class="markdownIt-Anchor" href="#7computed和watch区别">#</a> 7.computed 和 watch 区别</h4>
<p>computed 是计算属性，他是支持缓存的。他组件被挂载的时候就会被调用一次，当数据源信息比如 data 里的数据还有 props 接受的数据被更改的时候，会再次被调用，而 watch 是监听属性，watch 需要添加 immediate 才会在挂载时执行一次，他也能实现 computed 的功能，但是 watch 还可以做异步的操作，而 computed 只能做同步的，而且我们可以用 watch 做一些复杂的计算，computed 适合多个数据影响一个数据，就是用在了计算购物车结算总金额的时候，watch 适合一个数据影响多个数据，然后 watch 是用在了搜索的时候。</p>
<h4 id="8let-const-var的区别"><a class="markdownIt-Anchor" href="#8let-const-var的区别">#</a> 8.let const var 的区别</h4>
<p>var 存在变量提升，定义之前被使用会提示 undefined，let 和 const 不存在变量提升</p>
<p>var 不存在块级作用域，let 和 const 存在</p>
<p>var 不存在作用域死区，let 和 const 存在，当他们被声明那条语句执行了，才可以被使用</p>
<p>var 声明的变量可以重复声明，但是 let 和 const 不可以</p>
<p>var 和 let 声明的变量可以被修改，const 声明的常量不可以被修改。</p>
<p>const 开辟一个新的空间，</p>
<h4 id="9数组函数"><a class="markdownIt-Anchor" href="#9数组函数">#</a> 9. 数组函数</h4>
<p>shift（）、unshift（）、pop（）、push（）、reverse（）、sort（）、splice（）、</p>
<p>forEach（）、filter（）、reduce（）、findIndex（）、indexOf（）、every（）、some（）、map（）、join（）转换成字符串</p>
<h4 id="10keep-alive"><a class="markdownIt-Anchor" href="#10keep-alive">#</a> 10.keep-alive</h4>
<p>keep-alive 是 vue 中内置组件，能在组件切换过程中将状态保留在内存中，防止重复传染 DOM,keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们，</p>
<p>keep-alive 有三个属性</p>
<p>include 匹配的组件会被缓存</p>
<p>exclude 匹配的组件不会被缓存</p>
<p>max 可以设置最多可以缓存多少实例。</p>
<p>与之对应的有两生命周期钩子，activated 和 deactivated，前者是当 keep-alive 包裹的组件被激活的时候调用，deactivated 是当被 keep-alive 缓存的组件被停用的时候调用。</p>
<h4 id="11v-if和v-show"><a class="markdownIt-Anchor" href="#11v-if和v-show">#</a> 11.v-if 和 v-show</h4>
<p>v-if 的切换会销毁和重新构建一个新的 DOM 节点，而 v-show 只是对 DOM 元素设置 css 样式，display：none 和 display：block</p>
<p>v-if 只有在条件为真的时候才会加载，而 v-show 在初始化的时候会加载，</p>
<p>v-if 在切换的时候内存消耗高，而 v-show 在初次加载的时候消耗高，</p>
<p>v-if 适合不频繁的切换，v-show 适合频繁的切换</p>
<h4 id="12v-if和v-for"><a class="markdownIt-Anchor" href="#12v-if和v-for">#</a> 12.v-if 和 v-for</h4>
<p>在 vue2 中，v-for 的优先级比 v-if 的高，在 vue3 中，v-if 的优先级比 v-for 高，不推荐一起使用，假如 v-for 要遍历一个 1 万条的数据，他会影响性能。</p>
<h4 id="13mvvm"><a class="markdownIt-Anchor" href="#13mvvm">#</a> 13.mvvm</h4>
<p>m 是 model 数据层，是用来存放数据的，v 是 view 视图层， 也就是显示给用户的 ui 界面，然后 vm 就是 view-model 视图模型层，他是连接 model 和 view 的桥梁，mvvm 是支持数据双向绑定的，首先</p>
<p>-new 一个 vue 实例，然后 compile 去编译解析模板，然后初始化视图，并在 watcher 里绑定一个更新的函数，然后 watcher 在 dep 添加一个函数，使用 observer 劫持监听所有的属性，当数据变化时 observer 去通知 dep，dep 通过 watcher 在 dep 中添加的监听函数，去通知 wacher 有变化，然后 watcher 中更新函数发现 watcher 有变化，通知 updater 去更新视图。</p>
<h4 id="14路由导航守卫"><a class="markdownIt-Anchor" href="#14路由导航守卫">#</a> <strong>14. 路由导航守卫</strong></h4>
<p>路由导航守卫有三种，</p>
<p>全局路由守卫</p>
<p>beforeEach 在路由跳转前触发，有三个参数 to、from、next，主要是用于登录验证，</p>
<p>是在 beforeEach 和 组件内 beforeRouteEnter 之后，afterEach 之前调用，</p>
<p>afterEach 他是在路由跳转完成后触发，参数包括 to,from，他发生在 beforeEach 和 beforeResolve 之后，beforeRouteEnter 之前。</p>
<p>组件内路由守卫：</p>
<p>beforeRouteEnter 路由进入之前被调用，参数也是 to、from、next，在全局守卫 beforeEach 和独享守卫 beforeEnter 之后，全局 beforeResolve 和全局 afterEach 之前调用，要注意的是该守卫内访问不到组件的实例，也就是 this 为 undefined，也就是他在 beforeCreate 生命周期前触发。在这个钩子函数中，可以通过传一个回调给 next 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数，可以在这个守卫中请求服务端获取数据，当成功获取并能进入路由时，调用 next 并在回调中通过 vm 访问组件实例进行赋值等操作。</p>
<p>beforeRouteUpdate 在当前路由改变时，并且该组件被复用（动态路由，）时调用，可以通过 this 访问实例。参数包括 to、from、next，还有是</p>
<p>beforeRouteLeave 导航离开该组件的对应路由时调用，可以访问组件实例的 this，参数包括 to、from、next。</p>
<p>独享路由守卫</p>
<p>beforeEnter， <code>beforeEnter</code>  和  <code>beforeEach</code>  完全相同，如果都设置则在 <code>beforeEach</code>  之后紧随执行，参数 to、from、next</p>
<p>执行顺序：beforeRouteLeave&gt;beforeEach&gt;beforeRouteUpdate&gt;beforeEnter&gt;beforeRouteEnter&gt;beforeResolve&gt;afterEach&gt;beforeRouteEnter</p>
<h4 id="15diff算法"><a class="markdownIt-Anchor" href="#15diff算法">#</a> 15.diff 算法</h4>
<p>他是比较同层的树节点的一种高效算法，他是同层比较，从两端开始向中间靠拢，遵循的是深度优先原则，比如说旧节点 abcd，新节点是 abecd。旧节点和新节点相同就复用了，旧节点有的，新节点没有，直接删除，旧节点没有的，新节点有的，直接添加 appendChild 这个节点。</p>
<h4 id="16路由传参"><a class="markdownIt-Anchor" href="#16路由传参">#</a> 16. 路由传参</h4>
<p>有两种传参的方式，一种是 query 传参，通过  <code>router-link</code>  组件的  <code>to</code>  属性实现，该方法的参数可以是一个字符串路径，也可以是数组对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明式</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;path:&#x27;Child&#x27;,query:&#123;id:123&#125;&#125;&quot;</span>&gt;进入<span class="title class_">Child</span>路由&lt;/router-link&gt;</span><br><span class="line"><span class="comment">//编程式传参(一般通过事件触发)</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;/Child&#x27;</span></span><br><span class="line">    <span class="attr">query</span>: &#123;</span><br><span class="line">         <span class="attr">id</span>: m.<span class="property">id</span>,</span><br><span class="line">         <span class="attr">title</span>: m.<span class="property">title</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//获取数据</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">id</span></span><br></pre></td></tr></table></figure>
<p>另一种是 <code>params</code>  传参，使用 params 传参时，to 用的是对象的写法，必须使用 name 配置项，to 也可以是字符串就得是路径了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明式</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;name:&#x27;Child&#x27;,params:&#123;id:123&#125;&#125;&quot;</span>&gt;进入<span class="title class_">Child</span>路由&lt;/router-link&gt;</span><br><span class="line"><span class="comment">//父路由编程式传参(一般通过事件触发)</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Child&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">    	<span class="attr">id</span>:<span class="number">123</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">id</span></span><br></pre></td></tr></table></figure>
<h4 id="17v-model"><a class="markdownIt-Anchor" href="#17v-model">#</a> 17.v-model</h4>
<p>1. 在 input 标签里，绑定 v-bind 用来记录值，然后就是再添加 @input，让绑定的 v-bind 值等于 e.target.value</p>
<p>2. 在 select 标签里，绑定 v-bind 用来记录值，然后就是再添加 @change 事件，让绑定的 v-bind 的值等于 e.target.value</p>
<h4 id="18插槽"><a class="markdownIt-Anchor" href="#18插槽">#</a> 18. 插槽</h4>
<p>插槽就是子组件中的提供给父组件使用的一个占位符，用 slot 表示，父组件可以在这个占位符中填充任意代码，然后该内容会将子组件的 slot 给替换掉。</p>
<p>第一个是默认插槽，他就是子组件里的 slot 没有设置 name，而父组件的内容也没有设置，他会默认把父组件没有设置名字的内容给替换到子组件没有设置 name 的 slot 组件中。</p>
<p>第二个是具名插槽，就是给插槽起了个名字 就是在 slot 中添加一个 name = 名字，可以放在不同的地方，然后父组件通过 v-slot：名字将指定父组件替换到子组件对应名字的 slot，v-slot 要和 template 一起搭配才可以使用。</p>
<p>第三个就是作用域插槽，通过插槽可以传数据，可以用来子组件向父组件传值，子组件中在 slot 里把数据名字写上，父组件里通过 scope = 子组件的数据名字，来接受子组件传过来的数据。子组件只用来传数据，父组件用来显示子组件的内容想要展示的样式。</p>
<h4 id="19动态添加类"><a class="markdownIt-Anchor" href="#19动态添加类">#</a> 19. 动态添加类</h4>
<p>class 他有一个参数，可以是三种类型，第一种写法是字符串 当名字不确定时，需要动态修改，第二种写法是对象，当要绑定的样式，个数不确定，名字也不确定时，第三种是数组写法，要绑定多个样式，个数确定，名字也确定，但是不确定使不使用的时候。</p>
<p>style 的用法和 class 一样，传值可以是数组也可以是对象。</p>
<h4 id="20-0102-03"><a class="markdownIt-Anchor" href="#20-0102-03">#</a> 20.  0.1+0.2 == 0.3</h4>
<p>0.1 加 0.2 是不等于 0.3 的， 我们进行任何加法运算的时候，首先都会转换成二进制进行计算，而 0.1 和 0.2 转换成二进制，会出现循环，当他们相加的时候，会截取一段进行相加，从而会导致截取后面的部分数据丢失，使得计算结果小于 0.3</p>
<h4 id="21判断数据是否数组类型"><a class="markdownIt-Anchor" href="#21判断数据是否数组类型">#</a> 21. 判断数据是否数组类型</h4>
<p>首先，判断一个数据属于什么类型，typeof 没法判断数据，数组是一个特殊的对象，所以我们用 instanceof 方法，去判断他的类型，然后也可由通过它的原型去判断是否为数组，ta 的 constructor 是否等于数组类型。或者是它的–proto–是否等于数组的原型 prototype</p>
<h4 id="22原型和原型链"><a class="markdownIt-Anchor" href="#22原型和原型链">#</a> 22. 原型和原型链</h4>
<p>js 的每个函数对象在创建的时候，都会生成一个 prototype 属性，这个属性指向一个对象，这个对象就是此函数的原型。该原型对象中有个属性为 constructor，指向该函数。然后通过构造函数创建出来的实例对象，其本身都有一个属性叫 __ proto __   这个属性会指向该实例对象的构造函数的原型对象，原型对象他是一个对象他也有 __ proto 属性，最终会指向 object 的原型对象，然后 object 的原型对象的 custructor 指向的是 object，object 的 prototype 属性又指向 obejcet 的原型对象，这样就形成了一个类似链条的关系，我们把这个就叫做原型链。</p>
<p>​	function hanshu(){</p>
<p>​	}</p>
<p>​	let a = new hanshu()</p>
<p>​	hanshu ().prototype = 函数的原型对象</p>
<p>​	hanshu () = hanshu ().prototype.constructor 函数的原型对象的 constructor</p>
<p>​	a._ <em>proto</em>_ = hanshu().prototype</p>
<h4 id="23es6-class"><a class="markdownIt-Anchor" href="#23es6-class">#</a> 23.es6 class</h4>
<p>class 是构造函数的另一种写法，他必须有 constructor 构造方法，用来做初始化的操作，也可以用 get 和 set 关键字，对某个属性设置存值函数和取值函数。在 class 中的方法前可以加一个 static，使该方法变为静态方法，他不会被继承，可以通过类来直接调用。我们生成的类也需要通过 new 去实例化一个对象，class 之间可以通过 extends 去继承别的类，子类必须要用 super 方法去调用继承父类的方法，</p>
<h4 id="24es6-的-setmap"><a class="markdownIt-Anchor" href="#24es6-的-setmap">#</a> 24.es6 的 set，map</h4>
<p>es6 中的 set 和数组类似，set 不可以有重复的元素，所以可以做去重操作，set 本身就是一个构造函数，我们可以使用 new set 去创建一个 set 集合，可以通过 add 方式向 set 集合中添加元素。set 还有 size 方法，用来返回长度，has 方法，判断集合内是否存在某个内容，返回的是布尔值，还有 delete 方法，删除集合内某个元素，返回的也是布尔值，最后一个 clear 方法，直接清空集合内容。我们可以使用。keys，values 和 forEach 方法遍历 set 集合。</p>
<p>array.from 可以把类数组变成数组</p>
<p>map 用于存储映射关系，之前我们一直是使用对象来存储映射关系的，之前我们是一直使用对象来存储映射关系的，map 的键和值都可以是任意类型的，map 本身也是一构造函数，也可以通过 new map 去实例化，他的实例有 size 属性，可以显示 map 的成员总数，还有 set 方法，可以设置键名和对应的值，如果键名重复，则更新键值，最后返回整个 map 结构，get 方法用来获取键名对应的值，如果找不到则返回 undefined，has 方法，用来判断某个键是否在 map 中，返回一个布尔值，还有 delete 方法，删除某个键，返回的也是布尔值，最后一个就是 clear，清除 map 的所有成员，map 可以用 keys 和 forEach 遍历。</p>
<h4 id="25解构赋值"><a class="markdownIt-Anchor" href="#25解构赋值">#</a> 25. 解构赋值</h4>
<p>es6 允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这样就称为结构赋值，</p>
<p>数组的结构赋值，当解构不成功时，变量的值就等于 undefined，解构赋值时允许给变量设置默认值，也是引用解构赋值的其他变量，但是该变量必须是已经声明的，不然就会报错。</p>
<p>然后对象的解构赋值与数组不同的是，数组是按顺序排列的，变量的取值由它的位置决定，而对象的属性没有顺序。变量必须与属行同名，才可以取到正确的值，字符串，函数参数也可以解构赋值。</p>
<h4 id="26animation和transition"><a class="markdownIt-Anchor" href="#26animation和transition">#</a> 26.animation 和 transition</h4>
<p>1、transition 需要去触发比如：点击事件、鼠标移入事件；而 animation 可以配合 @keyframe 可以不触发事件就触发这个动画</p>
<p>2、transition 触发一次播放一次；而 animation 则是可以设置很多的属性，比如循环次数，动画结束的状态等等；</p>
<p>3、transition 关注的是样式属性的变化，属性值和时间的关系是一个三次贝塞尔曲线；而 animation 作用于元素本身而不是样式属性，可以使用关键帧的概念，可以实现更自由的动画效果；</p>
<p>4、在性能方面：浏览器有一个主线程和排版线程；主线程一般是对 js 运行的、页面布局、生成位图等等，然后把生成好的位图传递给排版线程，而排版线程会通过 GPU 将位图绘制到页面上，也会向主线程请求位图等等；我们在用使用 aniamtion 的时候这样就可以改变很多属性，像我们改变了 width、height、postion 等等这些改变文档流的属性的时候就会引起，页面的回流和重绘，对性能影响就比较大，但是我们用 transition 的时候一般会结合 tansfrom 来进行旋转和缩放等不会生成新的位图，当然也就不会引起页面的重排了。</p>
<h4 id="27-transform-transition-animation"><a class="markdownIt-Anchor" href="#27-transform-transition-animation">#</a> 27. transform、transition、animation</h4>
<p>transform</p>
<p>做过轮播图，和钟表，</p>
<h4 id="28响应式"><a class="markdownIt-Anchor" href="#28响应式">#</a> 28. 响应式</h4>
<p>响应式页面的设计与开发应当根据用户行为以及设备屏幕不同大小，进行相应的响应和调整。他的原理就是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有 <code>meta</code>  声明 <code>viewport</code></p>
<ul>
<li>
<p>width=device-width: 是自适应手机屏幕的尺寸宽度</p>
</li>
<li>
<p>maximum-scale: 是缩放比例的最大值</p>
</li>
<li>
<p>inital-scale: 是缩放的初始化</p>
</li>
<li>
<p>user-scalable: 是用户的可以缩放的操作</p>
<p>实现响应式布局的方式有如下：媒体查询、百分比、vw/vh、rem</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//head里配置</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">//css里设置</span></span></span><br><span class="line"><span class="string"><span class="tag">@media screen and (max-width: 1920px)&#123;&#125;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="29闭包"><a class="markdownIt-Anchor" href="#29闭包">#</a> 29. 闭包</h4>
<p>闭包可以简单理解成：定义在一个函数内部的函数。由于在 JS 中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之被收回，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数 — 也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后，作用域内的值也不会被销毁。</p>
<p>闭包就是定义在函数内部的一个函数，也就是函数内部嵌套函数。函数内部可以引用外部的参数和变量。然后就是参数和变量不会被回收。使用闭包可以避免全局变量的污染；缺点就是会使变量长期驻扎在内存中；会造成内存泄露。应用在 Ajax 请求的成功回调，事件绑定的回调方法， setTimeout 的延时回调。</p>
<h4 id="30防抖和节流"><a class="markdownIt-Anchor" href="#30防抖和节流">#</a> 30. 防抖和节流</h4>
<p>防抖和节流本质上是优化高频率执行代码的一种手段，有的事件会一直触发，会导致资源浪费，性能降低。所以采用防抖和节流 的方式来减少调用频率。节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效。防抖: n 秒后再执行该事件，若在 n 秒内被重复触发，则重新计时。防抖关注一定时间连续触发的事件，在一段连续操作结束后，处理回调。而节流，在一段连续操作中，每一段时间只执行一次。</p>
<h4 id="31深浅拷贝"><a class="markdownIt-Anchor" href="#31深浅拷贝">#</a> 31. 深浅拷贝</h4>
<p>浅拷贝和深拷贝在拷贝时都会创建一个新的对象</p>
<p>浅拷贝时，只会拷贝第一层，如果是基本类型，直接拷贝值，如果是引用类型，则拷贝内存地址。如果对象里有引用类型，修改新对象，原对象也会被修改。</p>
<p>深拷贝时，会开辟一个新的栈，两个对象属性完成相同，但是对应两个不同的地址。修改新对象，不会影响原对象。</p>
<p>浅拷贝直接用一个 for 循环遍历一次就可以实现，深拷贝则需要用到递归才能实现。</p>
<p>浅拷贝的方法有： <code>Object.assign、concat、lodash.clone</code></p>
<p>深拷贝方法有： <code>jQuery.extend()、JSON.stringify()、lodash.cloneDeep()</code></p>
<p>json.stringify 的缺陷会忽略 undefined 和 symbol 和函数</p>
<h4 id="33js数据类型"><a class="markdownIt-Anchor" href="#33js数据类型">#</a> 33.js 数据类型</h4>
<p>基本数据类型：number、string、boolean、undefined、null、symbol，</p>
<p>引用数据类型：array、object、function</p>
<h4 id="34隐式转换"><a class="markdownIt-Anchor" href="#34隐式转换">#</a> 34. 隐式转换</h4>
<p>js 中的隐式转换分为两种，一个是数学运算符中的转换，一个是逻辑语句中的转换，我们在对各种不是 number 类型的使用数学运算符时（- * /) 时，会先将非 Number 类型转换为 Number 类型。</p>
<p>然后加法的时候，分三种情况，</p>
<p>一侧是字符串时，会被当做字符串拼接，先把另一侧转为字符串类型。</p>
<p>一侧是 number 类型，另一侧是基本类型时，则将原、基本类型转换为 number 类型，</p>
<p>一侧是 number 类型，另一侧是引用类型时，将引用类型和 number 类型转换成字符串后拼接。</p>
<p>然后就是当字符串和数字、布尔值比较时都会转换为数字，再比较。</p>
<p>当对象和布尔值、字符串、数字比较时，对象都先转换为字符串，除字符串其他都要转为数字，再比较。</p>
<h4 id="35跨域"><a class="markdownIt-Anchor" href="#35跨域">#</a> 35. 跨域</h4>
<p>指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 javascript 施加的安全限制。</p>
<p>同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域；</p>
<p>document.domin 解决无法读取非同源网页的 cookie 问题，（此方案仅限主域相同，子域不同的跨域应用场景。）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个页面都设置</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;test.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>还可以使用 window.postMessage ()，它可用于解决以下方面的问题：页面和其打开的新窗口的数据传递，多窗口之间消息传递，页面与嵌套的 iframe 消息传递，上面三个场景的跨域数据传递</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父窗口打开一个子窗口</span></span><br><span class="line"><span class="keyword">var</span> openWindow = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;http://test2.com&#x27;</span>, <span class="string">&#x27;title&#x27;</span>);</span><br><span class="line"><span class="comment">// 父窗口向子窗口发消息(第一个参数代表发送的内容，第二个参数代表接收消息窗口的url)</span></span><br><span class="line">openWindow.<span class="title function_">postMessage</span>(<span class="string">&#x27;Nice to meet you!&#x27;</span>, <span class="string">&#x27;http://test2.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>3.JSONP，它是服务器与客户端跨源通信的常用方法，</p>
<p>原生 js，通过 script 标签使用 src，把请求地址写到这里面</p>
<p>使用 jquery 通过 ajax 发请求，url 放请求地址，type 请求类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vue中</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$http</span>.<span class="title function_">jsonp</span>(<span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">jsonp</span>: <span class="string">&#x27;handleCallback&#x27;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>4.CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。</p>
<p>1、普通跨域请求：只需服务器端设置 Access-Control-Allow-Origin</p>
<p>2、带 cookie 跨域请求：前后端都需要进行设置<br>
 5.vue 中使用 proxy 配置代理，解决跨域问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8080</span>,</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">target</span>: <span class="string">&quot;http://192.168.25.20:8088&quot;</span> <span class="comment">// 后端接口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>还有就是 websocket 和 nginx 反向代理也可以解决跨域问题</p>
<h4 id="36自定义指令"><a class="markdownIt-Anchor" href="#36自定义指令">#</a> 36. 自定义指令</h4>
<p>自定义指令可以通过 Vue.directive 方法进行全局注册，它有两个参数，第一个是指令的名字，第二参数是对象数据，也可以是一个指令函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.<span class="title function_">focus</span>()  <span class="comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>局部注册通过在组件 <code>options</code>  选项中设置 <code>directive</code>  属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">  <span class="attr">focus</span>: &#123;</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">      el.<span class="title function_">focus</span>() <span class="comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在模板中使用 v - 指令名字就可以使用了，</p>
<p>自定义指令常用的钩子函数有，</p>
<p>bind 只调用一次，指令与元素成功绑定时调用。</p>
<p>inserted：指令所在元素被插入页面时调用。</p>
<p>update：指令所在模板结构被重新解析时调用。</p>
<p>自定义指令用在判断用户权限，比如说一个数据，管理员可以看到删除按钮，而用户只能看到这条数据。</p>
<h4 id="37minxs"><a class="markdownIt-Anchor" href="#37minxs">#</a> 37.minxs</h4>
<p>对于一些在多个页面都会用到的方法和功能可以写在 mixns 中，之后每次用到只需引入 mixin 文件到用到的页面即可实现复用。<br>
mixin 文件的定义与正常 vue 组件的定义完全一致，都有 created,mounted… 等钩子函数，以及 data,methods 方法用来声明当前用到的数据和方法。minix 会在引入文件 中进行 属性和方法的合并（混入）minxs 优先执行，相同字段名首先会覆盖。相同函数名会合并为一个数组会优先执行 minix。</p>
<h4 id="38深度监听"><a class="markdownIt-Anchor" href="#38深度监听">#</a> 38. 深度监听</h4>
<p>watch 里的 deep 属性改为 true，开启深度监听</p>
<h4 id="39修改element-ui"><a class="markdownIt-Anchor" href="#39修改element-ui">#</a> 39. 修改 element-ui</h4>
<p>组件库中标签名字，就是 class 属性的名字，我们直接在 style 里重新给这个标签设置 css 属性值就可以改变默认样式，有的时候可能需要加上！important。’deep‘</p>
<h4 id="40封装echarts"><a class="markdownIt-Anchor" href="#40封装echarts">#</a> 40. 封装 echarts</h4>
<p>选择器权重， id &gt; 类 = 伪类 &gt; 标签 &gt; 伪元素</p>
<h4 id="41json和map的区别"><a class="markdownIt-Anchor" href="#41json和map的区别">#</a> 41.json 和 map 的区别</h4>
<p>map 里边的键值可以使任意，json 必须是字符串。</p>
<h4 id="42call-apply-bind"><a class="markdownIt-Anchor" href="#42call-apply-bind">#</a> 42.call apply bind</h4>
<p>call、apply、bind 作用是改变函数的 this 指向，</p>
<p>apply 接受两个参数，第一个参数是 this 参数是函数接受的参数，以数组的形式传入改变 this 指向后原函数会立即执行，且此方法只是临时改变 this 指向一次，当第一个参数为 null、undefined 的时候，默认指向 window。</p>
<p>call 方法的第一个参数也是 this 的指向，后面传入的是一个参数列表。跟 apply 一样，改变 this 指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。当第一个参数为 null、undefined 的时候，默认指向 window。</p>
<p>bind 方法和 call 相似，第一参数也是 <code>this</code>  的指向，后面传入的也是一个参数列表 (但是这个参数列表可以分多次传入)。改变 <code>this</code>  指向后不会立即执行，而是返回一个永久改变 <code>this</code>  指向的函数。</p>
<h4 id="43javascript垃圾回收机制"><a class="markdownIt-Anchor" href="#43javascript垃圾回收机制">#</a> 43.JavaScript 垃圾回收机制</h4>
<h5 id="1标记清除"><a class="markdownIt-Anchor" href="#1标记清除">#</a> 1. 标记清除：</h5>
<p>原理：当变量进入环境时，将这个变量标记为 “进入环境”。当变量离开环境时，则将其标记为 “离开环境”。标记 “离开环境” 的就回收内存。</p>
<p>垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。去掉环境中的变量以及被环境中的变量引用的变量的标记。<br>
再被加上标记的会被视为准备删除的变量。垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。</p>
<h5 id="2引用计数"><a class="markdownIt-Anchor" href="#2引用计数">#</a> 2. 引用计数</h5>
<p>原理：跟踪记录每个值被引用的次数。</p>
<p>声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是 1。<br>
同一个值又被赋值给另一个变量，这个引用类型值的引用次数加 1。<br>
当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减 1。<br>
当引用次数变成 0 时，说明没办法访问这个值了。<br>
当垃圾收集器下一次运行时，它就会释放引用次数是 0 的值所占的内存。</p>
<h4 id="44js中的defer和anysc"><a class="markdownIt-Anchor" href="#44js中的defer和anysc">#</a> 44.js 中的 defer 和 anysc</h4>
<p>defer 是不会阻塞 html 解析的，它是等 DOM 加载完之后再去执行 JavaScript 代码；async 是 JavaScript 下载完成，就会立即执行代码，等待执行完之后才继续解析 HTML。</p>
<p>在加载多个 JS 脚本的时候，async 是无顺序的加载，而 defer 是有顺序的加载。</p>
<h4 id="45宏任务与微任务"><a class="markdownIt-Anchor" href="#45宏任务与微任务">#</a> 45. 宏任务与微任务</h4>
<h5 id="微任务"><a class="markdownIt-Anchor" href="#微任务">#</a> 微任务</h5>
<p>一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前</p>
<p>常见的微任务有：</p>
<ul>
<li>Promise.then</li>
<li>MutaionObserver</li>
<li>Object.observe（已废弃；Proxy 对象替代）</li>
<li>process.nextTick（Node.js）</li>
</ul>
<h5 id=""><a class="markdownIt-Anchor" href="#">#</a> <a href="https://vue3js.cn/interview/JavaScript/event_loop.html#%E5%AE%8F%E4%BB%BB%E5%8A%A1">#</a>宏任务</h5>
<p>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合</p>
<p>常见的宏任务有：</p>
<ul>
<li>script (可以理解为外层同步代码)</li>
<li>setTimeout/setInterval</li>
<li>UI rendering/UI 事件</li>
<li>postMessage、MessageChannel</li>
<li>setImmediate、I/O（Node.js）</li>
</ul>
<h4 id="46阻止冒泡事件有三种方法"><a class="markdownIt-Anchor" href="#46阻止冒泡事件有三种方法">#</a> 46. 阻止冒泡事件有三种方法：</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>event.<span class="title function_">stopPropagation</span>()方法</span><br><span class="line">	$(<span class="string">&#x27;.btn&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params">even</span>) &#123;</span><br><span class="line">		even.<span class="title function_">stopPropagation</span>();</span><br><span class="line">		<span class="title function_">alert</span>(<span class="string">&#x27;按钮被点击了&#x27;</span>);</span><br><span class="line">	&#125;)</span><br><span class="line">这是阻止</span><br></pre></td></tr></table></figure>
<p>事件的冒泡方法，不让事件向 documen 上蔓延，但是默认事件任然会执行，当你掉用这个方法的时候，如果点击一个连接，这个连接仍然会被打开。<br>
例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span>event.<span class="title function_">preventDefault</span>()方法</span><br><span class="line">	$(<span class="string">&#x27;.btn&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params">even</span>) &#123;</span><br><span class="line">		even.<span class="title function_">preventDefault</span>();</span><br><span class="line">		<span class="title function_">alert</span>(<span class="string">&#x27;按钮被点击了&#x27;</span>);</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p>这是阻止默认事件的方法，调用此方法是，连接不会被打开，但是会发生冒泡，冒泡会传递到上一层的父元素；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">3.</span><span class="keyword">return</span> <span class="literal">false</span> ；</span><br><span class="line">	$(<span class="string">&#x27;.btn&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params">even</span>) &#123;</span><br><span class="line">		<span class="title function_">alert</span>(<span class="string">&#x27;按钮被点击了&#x27;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p>这个方法比较暴力，他会同事阻止事件冒泡也会阻止默认事件；写上此代码，连接不会被打开，事件也不会传递到上一层的父元素；可以理解为 return false 就等于同时调用了 event.stopPropagation () 和 event.preventDefault ()</p>
<h4 id="47返回url"><a class="markdownIt-Anchor" href="#47返回url">#</a> 47. 返回 url</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">		<span class="keyword">var</span> url;	</span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>; <span class="comment">/* 获取完整URL */</span></span><br><span class="line">	<span class="title function_">alert</span>(url); <span class="comment">/* http://127.0.0.1:8020/Test/index.html#test?name=test */</span></span><br><span class="line"></span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>; <span class="comment">/* 获取文件路径（文件地址） */</span></span><br><span class="line">	<span class="title function_">alert</span>(url); <span class="comment">/* /Test/index.html */</span></span><br><span class="line"></span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">protocol</span>; <span class="comment">/* 获取协议 */</span></span><br><span class="line">	<span class="title function_">alert</span>(url); <span class="comment">/* http */</span></span><br><span class="line"></span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">host</span>; <span class="comment">/* 获取主机地址和端口号 */</span></span><br><span class="line">	<span class="title function_">alert</span>(url); <span class="comment">/* http://127.0.0.1:8020/ */</span></span><br><span class="line"></span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hostname</span>; <span class="comment">/* 获取主机地址 */</span></span><br><span class="line">	<span class="title function_">alert</span>(url); <span class="comment">/* http://127.0.0.1/ */</span></span><br><span class="line"></span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">port</span>; <span class="comment">/* 获取端口号 */</span></span><br><span class="line">	<span class="title function_">alert</span>(url); <span class="comment">/* 8020 */</span></span><br><span class="line"></span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>; <span class="comment">/* 获取锚点（“#”后面的分段） */</span></span><br><span class="line">	<span class="title function_">alert</span>(url); <span class="comment">/* #test?name=test */</span></span><br><span class="line"></span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>; <span class="comment">/* 获取属性（“?”后面的分段） */</span></span><br><span class="line">	<span class="title function_">alert</span>(url);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果需要URL中的某一部分，可以自己进行处理 */</span></span><br><span class="line">	url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>;</span><br><span class="line">	url = url.<span class="title function_">substring</span>(url.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>, url.<span class="property">length</span>);</span><br><span class="line">	<span class="title function_">alert</span>(url); <span class="comment">/* /index.html */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * 如果页面使用了框架（frameset）</span></span><br><span class="line"><span class="comment">	 * 要获取到指定页面的URL</span></span><br><span class="line"><span class="comment">	 * 只要把window换成指定的页面即可</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* &#x27;frame&#x27;为指定页面的class名 */</span></span><br><span class="line">	<span class="keyword">var</span> url = <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="property">frames</span>[<span class="string">&#x27;frame&#x27;</span>].<span class="property">location</span>.<span class="property">href</span>;</span><br><span class="line">	<span class="comment">/* 获取当前地址栏中显示的URL */</span></span><br><span class="line">	<span class="keyword">var</span> url = <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="property">location</span>.<span class="property">href</span>;</span><br><span class="line">	<span class="comment">/* window parent 可互换 */</span></span><br><span class="line">	<span class="keyword">var</span> url = parent.<span class="property">window</span>.<span class="property">location</span>.<span class="property">href</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>vue面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>css笔记</title>
    <url>/2022/07/08/css%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="1-css有哪些选择器权重如何"><a class="markdownIt-Anchor" href="#1-css有哪些选择器权重如何">#</a> 1. css 有哪些选择器，权重如何</h4>
<p>通配符 *、id 选择器（#name）、标签选择器 (div)、类选择器 (.name)、伪类选择器 (hover、visited、link、active、focus)、伪元素选择器（before、after）、属性选择器</p>
<p>important&gt;id &gt; 类 = 伪类 &gt; 标签 = 伪元素 &gt; 通用</p>
<p>Css2 选择器：元素选择器，id 选择器，群组选择器，类选择器，* 通配符选择器，后代选择器</p>
<p>Css2 伪类选择器：a:link/visited/hover/active</p>
<p>Css3 选择器：空格 &gt;  + 相邻兄弟选择器～通用选择器（查找后面所有）</p>
<p>结构伪类选择器：</p>
<p>查找第几个 nth-child（n）、查找同一类型第几个 nth-of-type、查找唯一类型 only-of-type</p>
<dl>
<dt>属性选择器：根据标签属性查找 [attr=value]</dt>
<dd>
<p>root 查找根元素 html 标签</p>
</dd>
<dd>
<p>empty 查找空标签</p>
</dd>
</dl>
<p>目标伪类选择器：（表单）</p>
<p>：enabled 查找可以使用的标签、：disabled 查找禁止使用的标签、：checked 查找被选中的标签</p>
<p>伪元素选择器 ：：selection 设置选中文本内容的高亮显示（只能用于背景色和文本颜色）</p>
<p>否定伪类选择器 not（）</p>
<p>语言伪类选择器 lang（取值）</p>
<p>优先级（权重）：</p>
<p>元素选择器 1</p>
<p>伪元素选择器 1</p>
<p>class 选择器 10</p>
<p>伪类选择器 10</p>
<p>属性选择器 10</p>
<p>Id 选择器 100</p>
<p>内联样式的权重 1000</p>
<p>包含选择器权重为权重之和</p>
<p>继承样式权重为 0</p>
<p>那些属性可以继承：</p>
<p>Css 继承特性主要是文本方面</p>
<p>所有元素可继承：visibility 和 cursor</p>
<p>块级元素可继承：text-indent 和 text-align</p>
<p>列表元素可继承：list-style，list-style-type，list-style-position，list-style-image</p>
<p>内联元素可继承：letter-spacing，word-spacing，line-height，color，font，font-family，font-size</p>
<p>Font-style，font-variant，font-weight，text-decoration，text-transform，direction</p>
<p>字母间距 段落间距  行高   字体颜色 字体种类 字体大小 字体样式  字体粗细 小型大写字母文本 文本修饰 转换不同元素中的文本 文本方向</p>
<h4 id="2-float浮动元素引起的问题和解决方法"><a class="markdownIt-Anchor" href="#2-float浮动元素引起的问题和解决方法">#</a> 2. float 浮动元素引起的问题和解决方法</h4>
<p>float 会形成高度塌陷，怎么解决高度塌陷：</p>
<p>方法一：添加新空元素，再加上 clear:both</p>
<p>方法二：父元素定义 overflow:hidden; 形成了 BFC，</p>
<p>方法三：使用伪元素清除浮动</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;				<span class="comment">/*设置内容为空*/</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>:<span class="number">0</span>;				<span class="comment">/*高度为0*/</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>:<span class="number">0</span>;				<span class="comment">/*宽度为0*/</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">line-height</span>:<span class="number">0</span>;			<span class="comment">/*行高为0*/</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>:block;			<span class="comment">/*将文本转为块级元素*/</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">visibility</span>:hidden;		<span class="comment">/*将元素隐藏*/</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">clear</span>:both;				<span class="comment">/*清除浮动*/</span></span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-positionabsolute和float异同"><a class="markdownIt-Anchor" href="#3-positionabsolute和float异同">#</a> 3. Position：absolute 和 float 异同</h4>
<p>两者的共同点：对内联元素设置 float 或 absolute 属性，可以让元素脱离文档流（块级元素也可以），并且可以设置其宽高。</p>
<p>两者的不同点：float 仍会占位置，position 会覆盖文档流中的其他元素。</p>
<p>在左右布局时用浮动，其他用绝对定位 sition：absolute 浮动不会占位置</p>
<p>float 浮动的元素可以脱离标准文档流，摆脱块级元素和行内元素的限制，但是没有脱离文本流，因此<strong>仍然会占据位置</strong>，其他的文本内容会按照顺序继续排列。</p>
<p>不能共存，都能设置为 inline-block，</p>
<h4 id="4-display值有那些"><a class="markdownIt-Anchor" href="#4-display值有那些">#</a> 4. Display 值有那些</h4>
<p>none，block, inline-block,inline,flex,table 等</p>
<h4 id="5-浮动及其工作原理"><a class="markdownIt-Anchor" href="#5-浮动及其工作原理">#</a> 5. 浮动及其工作原理</h4>
<p>​	浮动的最主要作用是为了实现文字的包裹效果，随时技术的演进，后来实现的效果是为了将大片内容排布到一行上面，实现一个类似于导航栏的效果，然后就可以介绍一下清楚浮动。</p>
<h4 id="6-css-sprite雪碧图"><a class="markdownIt-Anchor" href="#6-css-sprite雪碧图">#</a> 6. Css Sprite（雪碧图）</h4>
<p>将页面中的图片汇成一张大图，加快页面加载，雪碧图在 处理小图标问题的时候可以大大减少服务器负担，但是在处理大量图片中，不建议用雪碧图。</p>
<h4 id="7-displaynone和visibilityhidden的区别"><a class="markdownIt-Anchor" href="#7-displaynone和visibilityhidden的区别">#</a> 7. Display：none 和 visibility：hidden 的区别</h4>
<p>display: none 隐藏后的元素不占据任何空间，</p>
<p>visibility: hidden 隐藏后的元素空间依旧保留</p>
<p>1、visibility 具有继承性，给父元素设置 visibility:hidden; 子元素也会继承这个属性。但是如果重新给子元素设置 visibility: visible, 则子元素又会显示出来。这个和 display: none 有着质的区别</p>
<p>2、visibility: hidden 不会影响计数器的计数，如图所示，visibility: hidden 虽然让一个元素不见了，但是其计数器仍在运行。这和 display: none 完全不一样</p>
<h4 id="8-px和rem区别"><a class="markdownIt-Anchor" href="#8-px和rem区别">#</a> 8. Px 和 rem 区别</h4>
<p>Px 固定长度</p>
<p>Rem：相对长度，相对于根元素，我们可以这样设置 @root {font-size:12px}，em 是相对于父元素的</p>
<h4 id="9bfc"><a class="markdownIt-Anchor" href="#9bfc">#</a> 9.BFC</h4>
<h5 id="1bfc到底是什么东西"><a class="markdownIt-Anchor" href="#1bfc到底是什么东西">#</a> 1.BFC 到底是什么东西</h5>
<p><code>BFC</code>  全称： <code>Block Formatting Context</code> ， 名为 “块级格式化上下文”。</p>
<p><code>W3C</code>  官方解释为： <code>BFC</code>  它决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用，当涉及到可视化布局时， <code>Block Formatting Context</code>  提供了一个环境， <code>HTML</code>  在这个环境中按照一定的规则进行布局。</p>
<p>简单来说就是， <code>BFC</code>  是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。那么怎么使用 <code>BFC</code>  呢， <code>BFC</code>  可以看做是一个 <code>CSS</code>  元素属性</p>
<h5 id="2怎样触发bfc"><a class="markdownIt-Anchor" href="#2怎样触发bfc">#</a> 2. 怎样触发 BFC</h5>
<p>这里简单列举几个触发 <code>BFC</code>  使用的 <code>CSS</code>  属性</p>
<p>overflow: hidden、display: inline-block、position: absolute、position: fixed、display: flex</p>
<p>1、float 的值不是 none。</p>
<p>2、position 的值不是 static 或者 relative。</p>
<p>3、display 的值是 inline-block、table-cell、flex、table-caption 或者 inline-flex</p>
<p>4、overflow 的值不是 visible</p>
<h5 id="3bfc的规则"><a class="markdownIt-Anchor" href="#3bfc的规则">#</a> 3.BFC 的规则</h5>
<p>BFC` 就是一个块级元素，块级元素会在垂直方向一个接一个的排列</p>
<p>BFC` 就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签</p>
<p>垂直方向的距离由 margin 决定， 属于同一个 <code>BFC</code>  的两个相邻的标签外边距会发生重叠</p>
<p>计算 <code>BFC</code>  的高度时，浮动元素也参与计算</p>
<h5 id="4可以解决"><a class="markdownIt-Anchor" href="#4可以解决">#</a> 4. 可以解决：</h5>
<p>高度塌陷，边距重叠，两栏布局</p>
<h4 id="10-什么是边距重叠结果是什么"><a class="markdownIt-Anchor" href="#10-什么是边距重叠结果是什么">#</a> 10. 什么是边距重叠，结果是什么</h4>
<p>两个元素的外边距可能重叠，上一个元素的 margin-bottom 和下一个元素的 margin-top 会发生重叠，</p>
<p>当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和 / 或下外边距也会发生合并。</p>
<p>当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和 / 或下外边距也会发生合并。</p>
<p>如果这个外边距遇到另一个元素的外边距，它还会发生合并</p>
<p>合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p>
<p>规则同号相加加绝对值，异号相加</p>
<h4 id="11-css如何隐藏元素"><a class="markdownIt-Anchor" href="#11-css如何隐藏元素">#</a> 11. Css 如何隐藏元素</h4>
<p>Opacity：0、display：none，visibility：hidden</p>
<h4 id="12-css画三角形"><a class="markdownIt-Anchor" href="#12-css画三角形">#</a> 12. Css 画三角形</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.trangle</span> &#123;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">border-width</span>: <span class="number">40px</span> <span class="number">40px</span>;</span><br><span class="line">		<span class="attribute">border-style</span>: solid;</span><br><span class="line">		<span class="attribute">border-color</span>: brown greenyellow red;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-css画心"><a class="markdownIt-Anchor" href="#13-css画心">#</a> 13. Css 画心</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.heartall</span>&#123;</span><br><span class="line">			<span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">			<span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">			<span class="attribute">background-color</span>: <span class="number">#ff3161</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="selector-class">.heart</span> &#123;</span><br><span class="line">			<span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">			<span class="attribute">margin-top</span>: <span class="number">200px</span>;</span><br><span class="line">			<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">			<span class="attribute">position</span>: relative;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.hearta</span> &#123;</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">left</span>: -<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.heartb</span> &#123;</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">top</span>: -<span class="number">100px</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;heart heartall&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hearta heartall&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;heartb heartall&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="14-盒模型的方式"><a class="markdownIt-Anchor" href="#14-盒模型的方式">#</a> 14. 盒模型的方式</h4>
<h5 id="1css盒子模型封装html元素"><a class="markdownIt-Anchor" href="#1css盒子模型封装html元素">#</a> 1.css 盒子模型封装 html 元素，</h5>
<p>包括 margin、padding、content、border</p>
<h5 id="2w3c盒子模型标准盒子模型"><a class="markdownIt-Anchor" href="#2w3c盒子模型标准盒子模型">#</a> 2.w3c 盒子模型（标准盒子模型）</h5>
<p>width 和 height 指的是内容区域 content 的宽高</p>
<p>盒子大小 四个相加</p>
<h5 id="3ie盒子模型-怪异盒子模型"><a class="markdownIt-Anchor" href="#3ie盒子模型-怪异盒子模型">#</a> 3.ie 盒子模型 （怪异盒子模型）</h5>
<p>width 指的是内容、边框、内边距总的宽度（content +border+padding）</p>
<p>height 指的是内容、边框、内边距总的高度</p>
<p>盒子的大小 = width（content + border + padding） + margin</p>
<h4 id="15-css新特性有哪些"><a class="markdownIt-Anchor" href="#15-css新特性有哪些">#</a> 15. Css 新特性有哪些</h4>
<p>选择器；first-of-type、last-of-type、only-of-type、only-child、</p>
<p>样式：boder-radius 圆角边框、box-shadow 阴影、border-image 边框图片</p>
<p>背景：background-clip 背景画裁剪、background-origin 对齐方式、background-size 背景图片大小；backgroup-position:(雪碧图上) background-break</p>
<h4 id="16word-wrap"><a class="markdownIt-Anchor" href="#16word-wrap">#</a> 16.word-wrap</h4>
<p>语法： <code>word-wrap: normal|break-word</code></p>
<ul>
<li>normal：使用浏览器默认的换行</li>
<li>break-all：允许在单词内换行</li>
</ul>
<h4 id="17text-overflow"><a class="markdownIt-Anchor" href="#17text-overflow">#</a> 17.text-overflow</h4>
<p><code>text-overflow</code>  设置或检索当当前行超过指定容器的边界时如何显示，属性有两个值选择：</p>
<ul>
<li>clip：修剪文本</li>
<li>ellipsis：显示省略符号来代表被修剪的文本</li>
</ul>
<p><code>text-shadow</code>  可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色</p>
<p>CSS 里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：</p>
<ul>
<li>text-fill-color: 设置文字内部填充颜色</li>
<li>text-stroke-color: 设置文字边界填充颜色</li>
<li>text-stroke-width: 设置文字边界宽度</li>
</ul>
<p>css3 <code>新增了新的颜色表示方式</code>  rgba <code>与</code>  hsla</p>
<ul>
<li>rgba 分为两部分，rgb 为颜色值，a 为透明度</li>
<li>hala 分为四部分，h 为色相，s 为饱和度，l 为亮度，a 为透明度</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition</span>： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><code>transform</code>  属性允许你旋转，缩放，倾斜或平移给定元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform-origin`：转换元素的位置（围绕那个点进行转换），默认值为`(x,y,z):(50%,50%,0)</span><br></pre></td></tr></table></figure>
<p>使用方式：</p>
<ul>
<li>transform: translate (120px, 50%)：位移</li>
<li>transform: scale (2, 0.5)：缩放</li>
<li>transform: rotate (0.5turn)：旋转</li>
<li>transform: skew (30deg, 20deg)：倾斜</li>
</ul>
<p>animation 也有很多的属性</p>
<ul>
<li>
<p>animation-name：动画名称</p>
</li>
<li>
<p>animation-duration：动画持续时间</p>
</li>
<li>
<p>animation-timing-function：动画时间函数</p>
</li>
<li>
<p>animation-delay：动画延迟时间</p>
</li>
<li>
<p>animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为 infinite，意思是无限循环</p>
</li>
<li>
<p>animation-direction：动画执行方向</p>
</li>
<li>
<p>animation-paly-state：动画播放状态</p>
</li>
<li>
<p>animation-fill-mode：动画填充模式</p>
</li>
<li>
<p>颜色渐变是指在两个颜色之间平稳的过渡， <code>css3</code>  渐变包括</p>
<ul>
<li>linear-gradient：线性渐变</li>
</ul>
<blockquote>
<p>background-image: linear-gradient(direction, color-stop1, color-stop2, …);</p>
</blockquote>
<ul>
<li>radial-gradient：径向渐变</li>
</ul>
<blockquote>
<p>linear-gradient(0deg, red, green);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex`弹性布局、`Grid</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h4 id="18-first-child和first-of-type区别"><a class="markdownIt-Anchor" href="#18-first-child和first-of-type区别">#</a> 18. First-child 和 first-of-type 区别</h4>
<p>first-child** 用于匹配父元素的第一个子元素，<em> 先选择在排序</em></p>
<p>first-of-type 选择器匹配属于其父元素的特定类型的首个子元素的每个元素，先排序，再选择</p>
<h4 id="19-css3动画"><a class="markdownIt-Anchor" href="#19-css3动画">#</a> 19… Css3 动画</h4>
<h5 id="1transition-实现渐变动画过度"><a class="markdownIt-Anchor" href="#1transition-实现渐变动画过度">#</a> 1.transition 实现渐变动画（过度）</h5>
<p>property: 填写需要变化的 css 属性</p>
<p>duration: 完成过渡效果需要的时间单位 (s 或者 ms)</p>
<p>timing-function: 完成效果的速度曲线</p>
<p>delay: 动画效果的延迟触发时间</p>
<h5 id="2transform-转变动画3"><a class="markdownIt-Anchor" href="#2transform-转变动画3">#</a> 2.transform 转变动画 3</h5>
<p>translate：位移</p>
<p>scale：缩放</p>
<p>rotate：旋转</p>
<p>skew：倾斜</p>
<h5 id="3animation-实现自定义动画"><a class="markdownIt-Anchor" href="#3animation-实现自定义动画">#</a> 3.animation 实现自定义动画</h5>
<ul>
<li>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>属性</td>
<td>描述</td>
<td>属性值</td>
</tr>
<tr>
<td>animation-duration</td>
<td>指定动画完成一个周期所需要时间，单位秒（s）或毫秒（ms），默认是 0</td>
<td></td>
</tr>
<tr>
<td>animation-timing-function</td>
<td>指定动画计时函数，即动画的速度曲线，默认是 “ease”</td>
<td>linear、ease、ease-in、ease-out、ease-in-out</td>
</tr>
<tr>
<td>animation-delay</td>
<td>指定动画延迟时间，即动画何时开始，默认是 0</td>
<td></td>
</tr>
<tr>
<td>animation-iteration-count</td>
<td>指定动画播放的次数，默认是 1</td>
<td></td>
</tr>
<tr>
<td>animation-direction 指定动画播放的方向</td>
<td>默认是 normal</td>
<td>normal、reverse、alternate、alternate-reverse</td>
</tr>
<tr>
<td>animation-fill-mode</td>
<td>指定动画填充模式。默认是 none</td>
<td>forwards、backwards、both</td>
</tr>
<tr>
<td>animation-play-state</td>
<td>指定动画播放状态，正在运行或暂停。默认是 running</td>
<td>running、pauser</td>
</tr>
<tr>
<td>animation-name</td>
<td>指定 @keyframes 动画的名称</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="20-box-sizing属性"><a class="markdownIt-Anchor" href="#20-box-sizing属性">#</a> 20. Box-sizing 属性</h4>
<p>规定两个并排的带边框的框</p>
<p>box-sizing 属性定义如何计算一个元素的总宽度和总高度，主要设置是否需要加上内边距 (padding) 和边框等。</p>
<p>例如，假如您需要并排放置两个带边框的框，可通过将 box-sizing 设置为 “border-box”。这样就可以让浏览器呈现出带有指定宽度和高度的框，并把边框和内边距放入框中。</p>
<p>默认情况下，元素的宽度 (width) 和高度 (height) 计算方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">width(宽度) + padding(内边距) + border(边框) = 元素实际宽度</span><br><span class="line">height(高度) + padding(内边距) + border(边框) = 元素实际高度</span><br></pre></td></tr></table></figure>
<h4 id="21css动画的优点"><a class="markdownIt-Anchor" href="#21css动画的优点">#</a> 21…Css 动画的优点</h4>
<p>浏览器可以对动画进行优化。</p>
<p>代码相对简单，性能调优方向固定</p>
<p>对于帧速表现不好的低版本浏览器，CSS3 可以做到自然降级</p>
<h4 id="22rem的原理"><a class="markdownIt-Anchor" href="#22rem的原理">#</a> 22…Rem 的原理</h4>
<p><strong>rem</strong> 是（根）字体大小相对单位，也就是说跟当前元素的 font-size 没有关系，而是跟整个 body 的 font-size 有关系。</p>
<p>Px，绝对长度单位，像素 px 是相对于显示器屏幕分辨率来说的</p>
<p>em 相对长度单位，相对于当前对象内文本的字体尺寸</p>
<pre><code> em的值并不是固定的

 em会继承父级元素的字体大小（参考物是父元素的font-size）

 em中所有的字体都是相对于父元素的大小决定的
</code></pre>
<h4 id="23-css3如何实现倒影"><a class="markdownIt-Anchor" href="#23-css3如何实现倒影">#</a> 23. Css3 如何实现倒影</h4>
<p>box-reflect 属性包括 3 个值。</p>
<h5 id="1-direction-定义方向取值包括-above-below-left-right"><a class="markdownIt-Anchor" href="#1-direction-定义方向取值包括-above-below-left-right">#</a> 1、direction 定义方向，取值包括 above 、 below 、 left 、 right。</h5>
<p>above：指定倒影在对象的上边</p>
<p>below：指定倒影在对象的下边</p>
<p>left：指定倒影在对象的左边</p>
<p>right：指定倒影在对象的右边</p>
<h5 id="2-offset定义反射偏移的距离取值包括数值或百分比其中百分比根据对象的尺寸进行确定-默认为0-用长度值来定义倒影与对象之间的间隔-可以为负值-用百分比来定义倒影与对象之间的间隔-可以为负值"><a class="markdownIt-Anchor" href="#2-offset定义反射偏移的距离取值包括数值或百分比其中百分比根据对象的尺寸进行确定-默认为0-用长度值来定义倒影与对象之间的间隔-可以为负值-用百分比来定义倒影与对象之间的间隔-可以为负值">#</a> 2、offset 定义反射偏移的距离，取值包括数值或百分比，其中百分比根据对象的尺寸进行确定。默认为 0。用长度值来定义倒影与对象之间的间隔。可以为负值。用百分比来定义倒影与对象之间的间隔。可以为负值。</h5>
<h5 id="3-mask-box-image定义遮罩图像该图像将覆盖投影区域-如果省略该参数值则默认为无遮罩图像"><a class="markdownIt-Anchor" href="#3-mask-box-image定义遮罩图像该图像将覆盖投影区域-如果省略该参数值则默认为无遮罩图像">#</a> 3、mask-box-image 定义遮罩图像，该图像将覆盖投影区域。如果省略该参数值，则默认为无遮罩图像。</h5>
<p>取值：</p>
<p>none：无遮罩图像：</p>
<p>使用绝对或相对地址指定遮罩图像。</p>
<p>使用线性渐变创建遮罩图像。</p>
<p>使用径向 (放射性) 渐变创建遮罩图像。</p>
<p>使用重复的线性渐变创建背遮罩像。</p>
<p>使用重复的径向 (放射性) 渐变创建遮罩图像。</p>
<h4 id="24-css定位详解"><a class="markdownIt-Anchor" href="#24-css定位详解">#</a> 24. Css 定位详解</h4>
<p>position</p>
<p><code>static</code>  是 <code>position</code>  属性的默认值。如果省略 <code>position</code>  属性，浏览器就认为该元素是 <code>static</code>  定位</p>
<p><code>relative</code>  表示，相对于默认位置（即 <code>static</code>  时的位置）进行偏移，即定位基点是元素的默认位置。</p>
<p><code>absolute</code>  表示，相对于上级元素（一般是父元素）进行偏移，即定位基点是父元素。</p>
<p><code>fixed</code>  表示，相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口。这会导致元素的位置不随页面滚动而变化，好像固定在网页上一样。</p>
<p><code>sticky</code>  跟前面四个属性值都不一样，它会产生动态效果，很像 <code>relative</code>  和 <code>fixed</code>  的结合：一些时候是 <code>relative</code>  定位（定位基点是自身默认位置），另一些时候自动变成 <code>fixed</code>  定位（定位基点是视口）。</p>
<h4 id="25-文本换行"><a class="markdownIt-Anchor" href="#25-文本换行">#</a> 25. 文本换行</h4>
<h5 id="word-break"><a class="markdownIt-Anchor" href="#word-break">#</a> word-break</h5>
<p>normal: 使用默认断行规则</p>
<p>break-all: 对于非 CJK 文本，可在任意字符间断行</p>
<p>keep-all:CJK 文本不断行，非 CJK 文本表现同 normal 一样</p>
<h4 id="26-省略号表示超出文本的内容"><a class="markdownIt-Anchor" href="#26-省略号表示超出文本的内容">#</a> 26. 省略号表示超出文本的内容</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">overflow: hidden;</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">white-space: nowrap;</span><br></pre></td></tr></table></figure>
<h4 id="27-如何给盒子添加蒙版"><a class="markdownIt-Anchor" href="#27-如何给盒子添加蒙版">#</a> 27. 如何给盒子添加蒙版</h4>
<p>设置背景颜色，给盒子内元素设置不透明度</p>
<h4 id="28-css3制作淡入淡出效果"><a class="markdownIt-Anchor" href="#28-css3制作淡入淡出效果">#</a> 28. Css3 制作淡入淡出效果</h4>
<p>animation 动画：名字，时间，类型、延迟时间、循环次数、等</p>
<p>@keyFrames 设置几个过度，设置不同的透明度</p>
<h4 id="29-css设置文本阴影"><a class="markdownIt-Anchor" href="#29-css设置文本阴影">#</a> 29. Css 设置文本阴影</h4>
<p>text-shadow: 水平、垂直</p>
<h4 id="30-css设置边框阴影"><a class="markdownIt-Anchor" href="#30-css设置边框阴影">#</a> 30. Css 设置边框阴影</h4>
<p>box-shadow 水平、垂直</p>
<h4 id="31css水平和垂直居中"><a class="markdownIt-Anchor" href="#31css水平和垂直居中">#</a> 31.Css 水平和垂直居中</h4>
<p>文字和盒子的居中</p>
<h4 id="32如何画一条05px的线"><a class="markdownIt-Anchor" href="#32如何画一条05px的线">#</a> 32. 如何画一条 0.5px 的线</h4>
<p>先把内容区域变成 200%，然后用 transform:scale (0.5) 将其变成一半，这样子就会画出 0.5px 的线</p>
<h4 id="33三栏布局方式两边固定中间自适应"><a class="markdownIt-Anchor" href="#33三栏布局方式两边固定中间自适应">#</a> 33. 三栏布局方式两边固定中间自适应</h4>
<p>1.margin 负值法：左右两栏均左浮动，左右两栏采用负的 margin 值。中间栏被宽度为 100% 的浮动元素包起来</p>
<p>2. 自身浮动法：左栏左浮动，右栏右浮动，中间栏放最后</p>
<p>3. 绝对定位法：左右两栏采用绝对定位，分别固定于页面的左右两侧，中间的主体栏用左右 margin 值撑开距离。</p>
<p>4.flex  左右固定宽  中间 flex：1</p>
<p>5. 网格布局</p>
<p>6.table 布局</p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>vue开发遇到的问题总结</title>
    <url>/2022/07/08/vue%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="1vue组件重新渲染"><a class="markdownIt-Anchor" href="#1vue组件重新渲染">#</a> 1.vue 组件重新渲染</h4>
<h5 id="1使用v-if"><a class="markdownIt-Anchor" href="#1使用v-if">#</a> 1. 使用 v-if</h5>
<p>v-if 可以实现 true 和 false</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html </span></span><br><span class="line">&lt;<span class="title class_">CompTable</span> ref=<span class="string">&quot;CompTable&quot;</span> v-<span class="keyword">if</span>=<span class="string">&quot;tableShow&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">tableShow</span>: <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">method</span>: &#123;</span><br><span class="line">	<span class="comment">// 触发更新事件</span></span><br><span class="line">	<span class="title function_">updateTable</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="comment">// 卸载</span></span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">tableShow</span>= <span class="literal">false</span></span><br><span class="line">		<span class="comment">// 建议加上 nextTick 微任务 </span></span><br><span class="line">		<span class="comment">// 否则在同一事件内同时将tableShow设置false和true有可能导致组件渲染失败</span></span><br><span class="line">		<span class="variable language_">this</span>.$nextTick(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="comment">// 加载</span></span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">tableShow</span>= <span class="literal">true</span></span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2组件中使用-key推荐"><a class="markdownIt-Anchor" href="#2组件中使用-key推荐">#</a> 2. 组件中使用 ：key（推荐）</h5>
<p>如果每次在当前父页面重新更新时冲在子组件就可以用这个方法，每次时间不同，key 就发生改变就会重新渲染页面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">CompTable</span> ref=<span class="string">&quot;CompTable&quot;</span> :key=<span class="string">&quot;new Date().getTime()&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p><strong>缺点：</strong> 如果当前组件同级有 input 输入框就尴尬了，每次输入都会重载这个 CompTable 组件，如果页面有表单就只能用 v-if 的形式了</p>
<h5 id="3使用forceupdate"><a class="markdownIt-Anchor" href="#3使用forceupdate">#</a> 3. 使用 forceUpdate</h5>
<p>对于数据更新但是 ui 没有更新的情况下可以使用。</p>
<p>迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$forceUpdate()</span><br></pre></td></tr></table></figure>
<h5 id="4关于-nexttick"><a class="markdownIt-Anchor" href="#4关于-nexttick">#</a> 4. 关于 $nextTick</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官网上的说法：为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即 使用 Vue.nextTick(callback)。这样 回调函数将在 DOM 更新完成后被调用。</span><br></pre></td></tr></table></figure>
<h4 id="2修改props的值"><a class="markdownIt-Anchor" href="#2修改props的值">#</a> 2. 修改 props 的值</h4>
<p>当在子组件中修改父组件中传过来的值的时候，会报错，</p>
<h5 id="1重新命名赋值"><a class="markdownIt-Anchor" href="#1重新命名赋值">#</a> 1. 重新命名赋值</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;<span class="title class_">Parent</span> :name=<span class="string">&#x27;name&#x27;</span>&gt;&lt;/<span class="title class_">Parent</span>&gt;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Children</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Children&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="attr">components</span>:&#123;</span><br><span class="line">        <span class="title class_">Children</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    	<span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;我是父组件的值呀&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line">&lt;<span class="title class_">Chidren</span> &gt;</span><br><span class="line">    &#123;&#123;cname&#125;&#125;</span><br><span class="line">&lt;/<span class="title class_">Children</span>&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="attr">props</span>:&#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">components</span>:&#123;</span><br><span class="line">        <span class="title class_">Children</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            cname = <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2通过绑定方法"><a class="markdownIt-Anchor" href="#2通过绑定方法">#</a> 2. 通过绑定方法</h5>
<p>过 emit 派发一个自定义事件，父组件收到后，由父组件进行修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">  <span class="attr">currentActiveNames</span>: &#123;</span><br><span class="line">   <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">activeNames</span> <span class="comment">//父组件传给子组件的值</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="title function_">set</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="comment">// 改变由父组件控制</span></span><br><span class="line">    <span class="variable language_">this</span>.$emit(<span class="string">&#x27;on-change-activeNames&#x27;</span>, val)   </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="comment">//父组件中在引用子组件的地方添加@on-change-activeNames=&quot;changeActiveNames&quot;，另外，在methods方法中定义changeActiveNames用来接收父组件传过来的值</span></span><br><span class="line">&lt;<span class="title class_">Children</span> @on-change-activeNames=<span class="string">&quot;changeActiveNames&quot;</span>&gt;&lt;/<span class="title class_">Chidren</span>&gt;</span><br><span class="line">methods：&#123;</span><br><span class="line"> <span class="title function_">changeActiveNames</span>(<span class="params">val</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(‘子组件传过来的值’，val)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3通过sync修饰符"><a class="markdownIt-Anchor" href="#3通过sync修饰符">#</a> 3. 通过.sync 修饰符</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   		<span class="tag">&lt;<span class="name">test</span> <span class="attr">:value.sync</span>=<span class="string">&quot;value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&#x27;@/components/test.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        test</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        	<span class="attr">value</span>: <span class="string">&#x27;父组件的值&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    	<span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    	<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span>改变父组件的值<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">value</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">type</span>: <span class="title class_">String</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        change () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:value&#x27;</span>, <span class="string">&#x27;在子组件中修改父组件的值&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="3"><a class="markdownIt-Anchor" href="#3">#</a> 3.</h4>
]]></content>
      <tags>
        <tag>vue、问题</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记</title>
    <url>/2022/07/11/js%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="1js基本数据类型有哪些"><a class="markdownIt-Anchor" href="#1js基本数据类型有哪些">#</a> 1.js. 基本数据类型有哪些</h4>
<p>基本数据类型（值类型）：字符串（String）、数字（Number）、布尔（Boolean）、空（Null）、未定义（Undefined）、</p>
<p>Symbol（相当于 id 自增 ）、BigInt</p>
<p>引用类型：对象（Object）、数组（Array）、函数（Function）</p>
<h4 id="2ajax如何使用"><a class="markdownIt-Anchor" href="#2ajax如何使用">#</a> 2.Ajax 如何使用</h4>
<p>一个完整的 AJAX 请求包括五个步骤：</p>
<p>创建 XMLHTTPRequest 对象<br>
使用 open 方法创建 http 请求，并设置请求地址<br>
 xhr.open（get/post，url，async，true（异步），false（同步））经常使用前三个参数</p>
<p>设置发送的数据，用 send 发送请求<br>
注册事件（给 ajax 设置事件）<br>
获取响应并更新页面</p>
<h4 id="3如何判断一个数据是nan"><a class="markdownIt-Anchor" href="#3如何判断一个数据是nan">#</a> 3. 如何判断一个数据是 NaN</h4>
<p>NaN 非数字 但是用 typeof 检测是 number 类型</p>
<p>利用 NaN 的定义  用 typeof 判断是否为 number 类型并且判断是否满足 isnan<br>
 利用 NaN 是唯一一个不等于任何自身的特点 n！<mark>n<br>
<a href="http://xn--ES6Object-sl6n09jd0jv55d4zwclje.is"> 利用 ES6 中提供的 Object.is</a> () 方法（判断两个值是否相等）  n</mark>nan<br>
Js 中 null 与 undefined 区别<br>
相同点：用 if 判断时，两者都会被转换成 false</p>
<p>不同点：</p>
<p>number 转换的值不同 number（null）为 0   number（undefined）为 NaN</p>
<p>Null 表示一个值被定义了，但是这个值是空值</p>
<p>Undefined 变量声明但未赋值</p>
<h4 id="4闭包是什么有什么特性对页面会有什么影响"><a class="markdownIt-Anchor" href="#4闭包是什么有什么特性对页面会有什么影响">#</a> 4. 闭包是什么？有什么特性？对页面会有什么影响</h4>
<p>闭包可以简单理解成：定义在一个函数内部的函数。其中一个内部函数在包含它们的外部函数之外被调用时，就会形成闭包。</p>
<p>特点：</p>
<p>1. 函数嵌套函数。</p>
<p>2. 函数内部可以引用外部的参数和变量。</p>
<p>3. 参数和变量不会被垃圾回收机制回收。</p>
<p>使用：</p>
<p>1. 读取函数内部的变量；</p>
<p>2. 这些变量的值始终保持在内存中，不会在外层函数调用后被自动清除。</p>
<p>优点：</p>
<p>1: 变量长期驻扎在内存中；</p>
<p>2: 避免全局变量的污染；</p>
<p>3: 私有成员的存在 ；</p>
<p>缺点：会造成内存泄露</p>
<h4 id="5js中常见的内存泄漏"><a class="markdownIt-Anchor" href="#5js中常见的内存泄漏">#</a> 5.Js 中常见的内存泄漏：</h4>
<p>1. 意外的全局变量</p>
<p>2. 被遗忘的计时器或回调函数</p>
<p>3. 脱离 DOM 的引用</p>
<p>4. 闭包</p>
<h4 id="6事件委托是什么如何确定事件源eventtarget-谁调用谁就是事件源"><a class="markdownIt-Anchor" href="#6事件委托是什么如何确定事件源eventtarget-谁调用谁就是事件源">#</a> 6. 事件委托是什么？如何确定事件源（Event.target  谁调用谁就是事件源）</h4>
<p>JS 高程上讲：事件委托就是利用事件冒泡，只制定一个时间处理程序，就可以管理某一类型的所有事件。</p>
<p>事件委托，称事件代理，是 js 中很常用的绑定事件的技巧，事件委托就是把原本需要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务，事件委托的原理是 DOM 元素的事件冒泡</p>
<h4 id="7什么是事件冒泡"><a class="markdownIt-Anchor" href="#7什么是事件冒泡">#</a> 7. 什么是事件冒泡？</h4>
<p>一个事件触发后，会在子元素和父元素之间传播，这种传播分为三个阶段，</p>
<p>捕获阶段（从 window 对象传导到目标节点（从外到里），这个阶段不会响应任何事件），目标阶段，（在目标节点上触发），冒泡阶段（从目标节点传导回 window 对象（从里到外）），事件委托 / 事件代理就是利用事件冒泡的机制把里层需要响应的事件绑定到外层</p>
<h4 id="9javascript垃圾回收机制"><a class="markdownIt-Anchor" href="#9javascript垃圾回收机制">#</a> 9.JavaScript 垃圾回收机制</h4>
<h5 id="1标记清除"><a class="markdownIt-Anchor" href="#1标记清除">#</a> 1. 标记清除：</h5>
<p>原理：当变量进入环境时，将这个变量标记为 “进入环境”。当变量离开环境时，则将其标记为 “离开环境”。标记 “离开环境” 的就回收内存。</p>
<p>垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。去掉环境中的变量以及被环境中的变量引用的变量的标记。<br>
再被加上标记的会被视为准备删除的变量。垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。</p>
<h5 id="2引用计数"><a class="markdownIt-Anchor" href="#2引用计数">#</a> 2. 引用计数</h5>
<p>原理：跟踪记录每个值被引用的次数。</p>
<p>声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是 1。<br>
同一个值又被赋值给另一个变量，这个引用类型值的引用次数加 1。<br>
当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减 1。<br>
当引用次数变成 0 时，说明没办法访问这个值了。<br>
当垃圾收集器下一次运行时，它就会释放引用次数是 0 的值所占的内存。<br>
（注意：当循环引用的时候就会释放不掉内存。）</p>
<p>三、如何观察内存泄漏？<br>
如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。</p>
<p>可以浏览器查看内存占用。<br>
通过命令行，命令行可以使用 Node process.memoryUsage 提供的方法。process.memoryUsage 返回一个对象，包含了 Node 进程的内存占用信息。（判断内存泄漏，以 heapUsed 字段为准。）</p>
<h4 id="10-script标签中defer和anysc属性的区别"><a class="markdownIt-Anchor" href="#10-script标签中defer和anysc属性的区别">#</a> 10. Script 标签中 defer 和 anysc 属性的区别</h4>
<p>defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码</p>
<p>async 属性表示异步执行引入的 JavaScript，即 javaScript 下载时 html 并未停止解析，等到 javaScript 下载完成，html 就停止解析，执行 javaScript 代码，等待 javaScript 执行完毕，浏览器再继续渲染。<br>
（1) defer 是不会阻塞 html 解析的，它是等 DOM 加载完之后再去执行 JavaScript 代码；async 是 JavaScript 下载完成，就会立即执行代码，等待执行完之后才继续解析 HTML。<br>
(2) 在加载多个 JS 脚本的时候，async 是无顺序的加载，而 defer 是有顺序的加载。</p>
<h4 id="11常见的javascript数组函数"><a class="markdownIt-Anchor" href="#11常见的javascript数组函数">#</a> 11. 常见的 JavaScript 数组函数</h4>
<p><img src="C:%5CUsers%5C17281%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220402131614815.png" alt="image-20220402131614815"></p>
<p><img src="C:%5CUsers%5C17281%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220402131643839.png" alt="image-20220402131643839"></p>
<p><img src="C:%5CUsers%5C17281%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220402131718324.png" alt="image-20220402131718324"></p>
<p><img src="C:%5CUsers%5C17281%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220402131820234.png" alt="image-20220402131820234"></p>
<p><img src="C:%5CUsers%5C17281%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220402131913971.png" alt="image-20220402131913971"></p>
<h4 id="12-encodeuri和decodeuri的区别是什么"><a class="markdownIt-Anchor" href="#12-encodeuri和decodeuri的区别是什么">#</a> 12. encodeURI () 和 decodeURI () 的区别是什么</h4>
<p>decodeURI () 函数可对 encodeURI () 函数编码过的 URI 进行解码。decodeURIComponent () 函数可对 encodeURIComponent () 函数编码的 URI 进行解码。</p>
<p>encodeURIComponent 和 decodeURIComponent 可以编码和<a href="https://so.csdn.net/so/search?q=%E8%A7%A3%E7%A0%81&amp;spm=1001.2101.3001.7020">解码</a> URI 特殊字符（如 #，/，￥等），而 decodeURI 则不能。</p>
<h4 id="13-null和undefined的区别"><a class="markdownIt-Anchor" href="#13-null和undefined的区别">#</a> 13. Null 和 undefined 的区别</h4>
<p>​         undefined 未定义的值：声明了一个变量，但没有赋值、访问对象上不存在的属性、函数定义了形参，但没有传递实参、使用 void 对表达式求值</p>
<p>​        null 空值: undefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。</p>
<h4 id="14-call和apply的区别"><a class="markdownIt-Anchor" href="#14-call和apply的区别">#</a> 14. Call 和 apply 的区别</h4>
<p>call 和 apply 两个方法最主要的作用就是改变 this 指向。</p>
<p>call () 方法的作用和 apply () 方法类似，区别就是 <code>call()</code>  方法接受的是参数列表，而 <code>apply()</code>  方法接受的是一个参数数组。</p>
<h4 id="15-哪些会造成内存泄露"><a class="markdownIt-Anchor" href="#15-哪些会造成内存泄露">#</a> 15. 哪些会造成内存泄露</h4>
<p>意外的全局变量： 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。<br>
被遗忘的计时器或回调函数： 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。<br>
脱离 DOM 的引用： 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。<br>
闭包： 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</p>
<h4 id="16-如何实现异步编程"><a class="markdownIt-Anchor" href="#16-如何实现异步编程">#</a> 16. 如何实现异步编程</h4>
<p>回调函数、事件监听、</p>
<h4 id="17-在js中为什么函数是第一类对象"><a class="markdownIt-Anchor" href="#17-在js中为什么函数是第一类对象">#</a> 17. 在 js 中，为什么函数是第一类对象</h4>
<p>在 js 中，函数也是对象，函数有对象的所有能力唯一的区别是函数是可调用的（invokable），即函数会被调用以便执行某项动作。</p>
<p><strong>对象</strong></p>
<ul>
<li>对象可以通过字面量来创建。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对象可以赋值给变量、数组项，或其他对象的属性。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;    <span class="comment">// 赋值给变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line">arr.<span class="title function_">push</span>(obj)     <span class="comment">// 赋值给数组项</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">data</span> = &#123;&#125;     <span class="comment">// 赋值给其他对象的属性</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对象可以作为函数的入参和出参。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> (obj) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;lin&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>对象可以动态创建和分配属性。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;lin&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>函数</strong></p>
<ul>
<li>函数可以通过字面量来创建。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> () &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数可以赋值给变量、数组项，或其他对象的属性。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;   <span class="comment">// 赋值给变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line">arr.<span class="title function_">push</span>(fn)     <span class="comment">// 赋值给数组项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">obj.<span class="property">fn</span> = fn     <span class="comment">// 赋值给其他对象的属性</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数可以作为函数的入参和出参，这是 JS 为何有闭包的一个重要原因。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> (callback) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">callback</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>函数可以动态创建和分配属性。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> () &#123;&#125;</span><br><span class="line"></span><br><span class="line">fn.<span class="property">name</span> = <span class="string">&#x27;lin&#x27;</span></span><br><span class="line">fn.<span class="property">age</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure>
<h4 id="18-函数声明和函数表达式的区别"><a class="markdownIt-Anchor" href="#18-函数声明和函数表达式的区别">#</a> 18. 函数声明和函数表达式的区别</h4>
<p>函数声明会被提升到作用于的前面，不论代码在什么地方、函数表达式声明不会被提升，自上而下的读取</p>
<h4 id="19-如何删除一个cookie"><a class="markdownIt-Anchor" href="#19-如何删除一个cookie">#</a> 19. 如何删除一个 cookie</h4>
<p>javascript 删除 cookie 的方法：首先通过 “setCookie” 设置 cookie；然后通过 “getCookie” 获取 cookie；最后通过 “clearCookie” 删除 cookie 即可。</p>
<h4 id="20-什么是闭包"><a class="markdownIt-Anchor" href="#20-什么是闭包">#</a> 20. 什么是闭包</h4>
<p>如果一个函数用到了它作用域外面的变量，那么这个变量和这个函数之间的环境就叫闭包</p>
<h5 id="1模仿块级作用域"><a class="markdownIt-Anchor" href="#1模仿块级作用域">#</a> 1. 模仿块级作用域</h5>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">X</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num.<span class="property">length</span>; i++)&#123;</span><br><span class="line">            num++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">call</span>() <span class="comment">//声明一个函数立即调用以后，浏览器刷新页面会报错，可以用一个小括号把整段函数包起来。</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)<span class="comment">//undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，闭包就是那个匿名函数，这个闭包可以当函数 X 内部的活动变量，又能保证自己内部的变量在自执行后直接销毁。这种写法经常用在全局环境中，可以避免添加太多全局变量和全局函数，特别是多人合作开发的时候，可以减少因此产生的命名冲突等，避免污染全局环境。</p>
<h5 id="2储存变量"><a class="markdownIt-Anchor" href="#2储存变量">#</a> 2. 储存变量</h5>
<p>闭包的另一个特点是可以保存外部函数的变量，内部函数保留了对外部函数的活动变量的引用，所以变量不会被释放。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">S</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            renturn a</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="title function_">S</span>() <span class="comment">// 100</span></span><br><span class="line"><span class="comment">//这种写法可以用在把一些不经常变动计算起来又比较复杂的值保存起来，节省每次的访问时间。</span></span><br></pre></td></tr></table></figure>
<h5 id="3封装私有变量"><a class="markdownIt-Anchor" href="#3封装私有变量">#</a> 3. 封装私有变量</h5>
<p>我们可以把函数当作一个范围，函数内部的变量就是私有变量，在外部无法引用，但是我们可以通过闭包的特点来访问私有变量。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//变量作用域为函数内部，外部无法访问</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;,</span><br><span class="line">        setName : <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;</span><br><span class="line">            name = newName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">print</span>(person.name);<span class="comment">//直接访问，结果为undefined</span></span><br><span class="line"><span class="keyword">print</span>(person.<span class="title function_ invoke__">getName</span>()); <span class="comment">// default</span></span><br><span class="line">person.<span class="title function_ invoke__">setName</span>(<span class="string">&quot;abruzzi&quot;</span>);</span><br><span class="line"><span class="keyword">print</span>(person.<span class="title function_ invoke__">getName</span>()); <span class="comment">// abruzzi</span></span><br></pre></td></tr></table></figure>
<h4 id="21-判断一个对象是否属于某个类"><a class="markdownIt-Anchor" href="#21-判断一个对象是否属于某个类">#</a> 21. 判断一个对象是否属于某个类</h4>
<p>typeof 对于判断除了 null 之外的基本类型时准确的，但无法判断 null、object、array 等类型，所以它只在区别对象和原始类型的时候才有用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">42</span>) <span class="comment">//number</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;blubber&#x27;</span>)<span class="comment">//string</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>)<span class="comment">//boolean</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> undeclaredVariable)<span class="comment">//undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>instanceof 运算符用于监测构造函数的 protopyte 属性时否出现在某个实例对象的原型链上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">//true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>() <span class="keyword">instanceof</span> <span class="title class_">Date</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>() <span class="keyword">instanceof</span> <span class="title class_">Person</span> <span class="comment">//true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>() <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>constructor 可以用来判断数据类型，但是除了 null、undefined，因为他们不是由对象构建。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数字</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">constructor</span>)</span><br><span class="line">f <span class="title class_">Number</span>()&#123;[native code]&#125;</span><br><span class="line"><span class="comment">//布尔值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span>.<span class="property">constructor</span>)</span><br><span class="line">f <span class="title class_">Boolean</span>()&#123;[native code]&#125;</span><br><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&#x27;</span>.<span class="property">constructor</span>)</span><br><span class="line">f <span class="title class_">Boolean</span>()&#123;[native code]&#125;</span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="keyword">var</span> func = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(func.<span class="property">constructor</span>)</span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([].<span class="property">constructor</span>)</span><br><span class="line">f <span class="title class_">Array</span>()&#123;[native code]&#125;</span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">constructor</span>)</span><br><span class="line">f <span class="title class_">Object</span>()&#123;[native code]&#125;</span><br></pre></td></tr></table></figure>
<p>终极方法，精准判断所有类型 Object.prototypr.toString.call ()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line">toString.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>);<span class="comment">//[object Date]</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">String</span>);<span class="comment">//[object String]</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="title class_">Math</span>);<span class="comment">//[object Math]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Since JavaScript 1.8.5</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="literal">undefined</span>);<span class="comment">//[object Undefined]</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="literal">null</span>);<span class="comment">//[object Null]</span></span><br></pre></td></tr></table></figure>
<h4 id="22-javascript实现数组合并方法"><a class="markdownIt-Anchor" href="#22-javascript实现数组合并方法">#</a> 22. JavaScript 实现数组合并方法</h4>
<p>普通数组，用 concat 合并数组，用 set 去重</p>
<p>数组对象，用 concat 合并，创建新数组对象，遍历去重保存到新数组里</p>
<h4 id="23-什么是事件代理"><a class="markdownIt-Anchor" href="#23-什么是事件代理">#</a> 23. 什么是事件代理</h4>
<p>“事件代理” 即是把原本需要绑定在子元素的响应事件（click、keydown…）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是 DOM 元素的事件冒泡。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> item1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;goSomewhere&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> item2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;doSomething&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> item3 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;sayHi&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> target = event.<span class="property">target</span></span><br><span class="line">	<span class="keyword">switch</span>(target.<span class="property">id</span>)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;goSomewhere&#x27;</span>:</span><br><span class="line">			<span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;事件委托&#x27;</span>;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;doSomething&#x27;</span>:</span><br><span class="line">			location.<span class="property">href</span> = <span class="string">&#x27;http://www.baidu.com&#x27;</span>;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;sayHi&#x27;</span>:</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="24-327结果是什么"><a class="markdownIt-Anchor" href="#24-327结果是什么">#</a> 24. 3+2+“7” 结果是什么</h4>
<p>57</p>
<h4 id="25-javascript里函数参数arguments"><a class="markdownIt-Anchor" href="#25-javascript里函数参数arguments">#</a> 25. JavaScript 里函数参数 arguments</h4>
<p>Javascrip 中每个函数都会有一个 Arguments 对象实例 arguments，它引用着函数的实参，可以用数组下标的方式 &quot;[]&quot; 引用 arguments 的元素。</p>
<h4 id="26-如何阻止事件冒泡"><a class="markdownIt-Anchor" href="#26-如何阻止事件冒泡">#</a> 26. 如何阻止事件冒泡</h4>
<h5 id="1eventstoppropagation方法"><a class="markdownIt-Anchor" href="#1eventstoppropagation方法">#</a> 1.event.stopPropagation () 方法</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;.btn&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params">even</span>)&#123;</span><br><span class="line">	even.<span class="title function_">stopPropagetion</span>();</span><br><span class="line">	<span class="title function_">alert</span>(;按钮被点击了)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//这是阻止事件冒泡的方法，不让事件像document上蔓延，但是默认事件仍然会执行，当你调用这个方法的时候，如果点击一个链接，这个链接仍然会被打开。</span></span><br></pre></td></tr></table></figure>
<h5 id="2eventpreventdefault方法"><a class="markdownIt-Anchor" href="#2eventpreventdefault方法">#</a> 2.event.preventDefault () 方法</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;.btn&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params">even</span>)&#123;</span><br><span class="line">	even.<span class="title function_">preventDefault</span>();</span><br><span class="line">	<span class="title function_">alert</span>(;按钮被点击了)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//这是阻止默认事件的方法，调用此方法是，链接不会被打开，但是会发生冒泡，冒泡会传递到上一层的父元素。</span></span><br></pre></td></tr></table></figure>
<h5 id="3return-false"><a class="markdownIt-Anchor" href="#3return-false">#</a> 3.return false</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;.btn&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params">even</span>)&#123;   </span><br><span class="line">    <span class="title function_">alert</span>(;按钮被点击了)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//这个方法比较暴力，他会同时阻止事件冒泡也会阻止默认事件；写上此代码。链接不会被打开，事件也不会传递到上一层的父元素。</span></span><br></pre></td></tr></table></figure>
<h4 id="27-什么是事件捕获和事件冒泡"><a class="markdownIt-Anchor" href="#27-什么是事件捕获和事件冒泡">#</a> 27. 什么是事件捕获和事件冒泡</h4>
<ul>
<li>事件捕获：由微软公司提出，事件从文档根节点（Document 对象）流向目标节点，途中会经过目标节点的各个父级节点，并在这些节点上触发捕获事件，直至到达事件的目标节点；</li>
<li>事件冒泡：由网景公司提出，与事件捕获相反，事件会从目标节点流向文档根节点，途中会经过目标节点的各个父级节点，并在这些节点上触发捕获事件，直至到达文档的根节点。整个过程就像水中的气泡一样，从水底向上运动。</li>
<li>在事件捕获阶段，事件会从 DOM 树的最外层开始，依次经过目标节点的各个父节点，并触发父节点上的事件，直至到达事件的目标节点。</li>
</ul>
<h4 id="28-js原型链的理解"><a class="markdownIt-Anchor" href="#28-js原型链的理解">#</a> 28. Js 原型链的理解</h4>
<p>js 的每个函数对象在创建的时候，都会生成一个 prototype 属性，这个属性指向一个对象，这个对象就是此函数的原型。该原型对象中有个属性为 constructor，指向该函数。然后通过构造函数创建出来的实例对象，其本身都有一个属性叫 __ proto __   这个属性会指向该实例对象的构造函数的原型对象，原型对象他是一个对象他也有 __ proto 属性，最终会指向 object 的原型对象，然后 object 的原型对象的 custructor 指向的是 object，object 的 prototype 属性又指向 obejcet 的原型对象，这样就形成了一个类似链条的关系，我们把这个就叫做原型链。</p>
<h4 id="29-什么是自执行函数可以用于那些场景"><a class="markdownIt-Anchor" href="#29-什么是自执行函数可以用于那些场景">#</a> 29. 什么是自执行函数，可以用于那些场景</h4>
<p>自执行函数，可以让函数在定义后立即被执行。主要用于创建一个新的作用域，在此作用域内声明的变量， 不会和其它作用域内的变量冲突或混淆， 大多是以匿名函数方式存在，且立即自动执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两种定义使用方法</span></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;)()</span><br><span class="line"><span class="keyword">var</span> a = (<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)()</span><br></pre></td></tr></table></figure>
<h4 id="30-0102会输出什么为什么"><a class="markdownIt-Anchor" href="#30-0102会输出什么为什么">#</a> 30. 0.1+0.2 会输出什么，为什么</h4>
<p>计算机在进行运算的时候，会转换成二进制，然后会出现无线循环，然后相加的时候会截取一部分，导致精度缺失，最后结果转成十进制会小于 0.3</p>
<h4 id="31-什么是跨域"><a class="markdownIt-Anchor" href="#31-什么是跨域">#</a> 31. 什么是跨域</h4>
<p>浏览器的同源策略造成的，解决方法见<a href="https://menglixunni.github.io/2022/07/07/vue%E9%9D%A2%E8%AF%95%E9%A2%98/#35%E8%B7%A8%E5%9F%9F"> vue 面试题</a>的 35 题。</p>
<h4 id="32-ajax是什么如何实现"><a class="markdownIt-Anchor" href="#32-ajax是什么如何实现">#</a> 32. Ajax 是什么，如何实现</h4>
<p>1.new   XMLHttpRequest  2.open （url，get/post） 3.  statechange 4. send</p>
<h4 id="33-数组转化成json如何转化回来"><a class="markdownIt-Anchor" href="#33-数组转化成json如何转化回来">#</a> 33. 数组转化成 JSON，如何转化回来</h4>
<p>var str = JSON.stringify(obj)</p>
<p>var obj2 = JSON.parse(str)</p>
]]></content>
      <tags>
        <tag>JavaScript、js</tag>
      </tags>
  </entry>
</search>
